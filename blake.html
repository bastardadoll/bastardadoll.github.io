<!DOCTYPE html>
<html lang="pt-br"> <!-- ‚ôªÔ∏è Definindo o idioma da p√°gina como portugu√™s brasileiro -->
<head>
  <meta charset="UTF-8"> <!-- ‚öôÔ∏è Define a codifica√ß√£o de caracteres para UTF-8, suportando acentos e s√≠mbolos -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- üì± Configura a viewport para responsividade em dispositivos m√≥veis -->
  <title>Tempo de Rea√ß√£o do Blake</title> <!-- üìÑ T√≠tulo que aparece na aba do navegador -->
  <style>
    /* ...existing code... */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  background-color: #0a1929;
  color: #fff;
}

.container {
  max-width: 1000px;
  margin: 0 auto;
  padding: 20px;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 10px;
  border-bottom: 3px solid #ff66cc;
}

h1 {
  color: #ff66cc;
  font-size: 2.5rem;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
}

.rainbow-flag {
  font-size: 2rem;
  animation: bounce 2s infinite;
}

.main-content {
  display: flex;
  flex-direction: row;
  gap: 20px;
}

.video-section {
  flex: 6;
  background: #1a2d3d;
  border-radius: 10px;
  padding: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.reaction-section {
  flex: 4;
  background: #1a2d3d;
  border-radius: 10px;
  padding: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.video-container {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

#video-upload {
  display: none;
}

#upload-label {
  padding: 40px;
  text-align: center;
  border: 3px dashed #aaa;
  border-radius: 8px;
  cursor: pointer;
  color: #888;
  transition: all 0.3s;
}

#upload-label:hover {
  background-color: #f5f5f5;
  border-color: #ff66cc;
  color: #ff66cc;
}

#video-player {
  width: 100%;
  border-radius: 8px;
  max-height: 400px;
  display: none;
}

.input-area {
  display: flex;
  margin-top: 10px;
  justify-content: flex-end;
}

#unload-video {
  padding: 8px 15px;
  background: #ff4466;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

.character {
  display: flex;
  align-items: flex-start;
  gap: 20px;
  margin-bottom: 20px;
}

#blake {
  width: 150px;
  height: auto;
  transition: transform 0.3s;
  filter: drop-shadow(0 0 5px rgba(255, 102, 204, 0.3));
}

.speech-bubble {
  position: relative;
  background: #1a2d3d;
  border: 2px solid #ff66cc;
  border-radius: 15px;
  padding: 15px;
  max-width: 300px;
  min-height: 80px;
  margin-top: 20px;
}

.speech-bubble:before {
  content: '';
  position: absolute;
  left: -20px;
  top: 20px;
  border: 10px solid transparent;
  border-right-color: #ff66cc;
}

.speech-bubble p {
  font-size: 1.1rem;
  color: #fff;
}

.hidden {
  display: none;
}

.controls {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

#react-button {
  padding: 12px 25px;
  background: #ff66cc;
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 1.1rem;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s;
}

#react-button:disabled {
  background: #cccccc;
  cursor: not-allowed;
}

#react-button:not(:disabled):hover {
  background: #ff33bb;
  transform: scale(1.05);
}

.reaction-indicator {
  margin-top: 10px;
}

.mood-meter {
  display: flex;
  align-items: center;
  gap: 10px;
}

.mood-label {
  font-weight: bold;
  color: #666;
}

#mood-bar {
  height: 20px;
  width: 100%;
  background: linear-gradient(to right, #ff0000, #ffff00, #00ff00, #0000ff, #ff00ff);
  border-radius: 10px;
  position: relative;
  overflow: hidden;
}

#mood-meter-fill {
  position: absolute;
  height: 100%;
  width: 0%;
  background-color: rgba(255, 255, 255, 0.3);
  transition: width 0.5s ease;
}

#mood-bar:after {
  display: none;
}

.mood-value {
  margin-top: 5px;
  text-align: right;
  font-size: 1.2rem;
  font-weight: bold;
}

.mood-selection {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
}

#mood-select {
  padding: 5px;
  border-radius: 4px;
  background: #1a2d3d;
  color: white;
  border: 1px solid #ff66cc;
}

.text-to-speech-toggle {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
}

.status-area {
  margin-top: 20px;
  text-align: center;
  padding: 10px;
  background: rgba(255, 102, 204, 0.1);
  border-radius: 8px;
  color: #fff;
}

#status-message {
  font-style: italic;
  color: #ccc;
}

.auto-reaction-toggle {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
}

.toggle-switch {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 24px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 24px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: #ff66cc;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

.chat-section {
  background: #1a2d3d;
  border-radius: 10px;
  padding: 15px;
  margin-top: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  height: 300px;
  display: flex;
  flex-direction: column;
  width: 100%;
}

.chat-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  padding-bottom: 5px;
  border-bottom: 2px solid #ff66cc;
}

.chat-header h3 {
  color: #ff66cc;
  margin: 0;
}

.chat-header-controls {
  display: flex;
  gap: 10px;
  align-items: center;
}

.add-chatter-btn {
  background: #ff66cc;
  color: white;
  border: none;
  border-radius: 5px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 0.8rem;
  transition: all 0.3s;
}

.add-chatter-btn:hover {
  background: #ff33bb;
}

.chat-messages {
  flex-grow: 1;
  overflow-y: auto;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  padding: 10px;
  margin-bottom: 10px;
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.chat-message {
  display: flex;
  align-items: flex-start;
  margin-bottom: 5px;
}

.chat-username {
  font-weight: bold;
  margin-right: 5px;
}

.chat-avatar {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  margin-right: 8px;
}

.chat-text {
  word-break: break-word;
}

.chat-input-area {
  display: flex;
  gap: 5px;
}

#chat-input {
  flex-grow: 1;
  padding: 8px;
  border-radius: 4px;
  border: 1px solid #444;
  background: rgba(0, 0, 0, 0.2);
  color: white;
}

#send-chat {
  padding: 8px 15px;
  background: #ff66cc;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.message-zangos .chat-username { color: #ff5722; }
.message-connie .chat-username { color: #2196f3; }
.message-beary .chat-username { color: #8bc34a; }
.message-starlight .chat-username { color: #9c27b0; }
.message-user .chat-username { color: #ff66cc; }

.debug-panel {
  background: #333;
  color: #0f0;
  padding: 5px 10px;
  font-size: 0.9rem;
  margin-bottom: 10px;
  position: relative;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.debug-toggle {
  position: absolute;
  right: 10px;
  top: 5px;
  background: #555;
  color: #fff;
  border: none;
  border-radius: 3px;
  padding: 2px 6px;
  font-size: 0.8rem;
  cursor: pointer;
}

.character-customizer {
  background: #1a2d3d;
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

#toggle-customizer {
  background: #ff66cc;
  color: white;
  border: none;
  border-radius: 5px;
  padding: 8px 15px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s;
}

#toggle-customizer:hover {
  background: #ff33bb;
}

#customizer-panel {
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #444;
}

.customizer-section {
  margin-bottom: 20px;
}

.customizer-section h3 {
  color: #ff66cc;
  margin-bottom: 10px;
}

.customizer-field {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
}

.customizer-field label {
  width: 120px;
  color: #ccc;
}

.customizer-field input, .customizer-field textarea {
  flex: 1;
  padding: 8px;
  background: rgba(0, 0, 0, 0.2);
  border: 1px solid #444;
  border-radius: 4px;
  color: white;
}

.customizer-field textarea {
  height: 60px;
  resize: vertical;
}

.customizer-images {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: space-between;
}

.mood-image-selector {
  width: 120px;
  text-align: center;
  margin-bottom: 15px;
  background: rgba(0, 0, 0, 0.2);
  padding: 10px;
  border-radius: 5px;
}

.mood-image-selector p {
  margin-bottom: 5px;
  color: #ccc;
}

.mood-image-selector img {
  width: 80px;
  height: 80px;
  object-fit: contain;
  margin-bottom: 5px;
}

.mood-image-input {
  display: none;
}

.mood-image-label {
  display: inline-block;
  padding: 5px 10px;
  background: #ff66cc;
  color: white;
  border-radius: 3px;
  cursor: pointer;
  font-size: 0.8rem;
}

.customizer-buttons {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}

.customizer-buttons button {
  padding: 8px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

#save-character {
  background: #4CAF50;
  color: white;
}

#reset-character {
  background: #f44336;
  color: white;
}

.hidden {
  display: none;
}

.streaming-panel {
  background: #1a2d3d;
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

#currently-streaming-btn {
  background: #ff66cc;
  color: white;
  border: none;
  border-radius: 5px;
  padding: 8px 15px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s;
  margin-right: 10px;
}

#currently-streaming-btn:hover {
  background: #ff33bb;
}

#streaming-panel {
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #444;
}

.streaming-characters-container {
  max-height: 400px;
  overflow-y: auto;
  margin-top: 15px;
}

.streaming-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.streaming-header h3 {
  color: #ff66cc;
  margin: 0;
}

.streaming-character {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.your-character {
  background: rgba(255, 102, 204, 0.15);
  border: 1px solid rgba(255, 102, 204, 0.3);
}

.character-info {
  flex: 1;
}

.character-info h4 {
  margin: 0 0 5px 0;
  color: #ff66cc;
}

.character-info p {
  margin: 0 0 5px 0;
  font-size: 0.9rem;
  color: #ddd;
}

.character-info .creator {
  font-size: 0.8rem;
}

.mood-boost-section {
  margin-top: 15px;
  background: rgba(255, 102, 204, 0.1);
  border-radius: 8px;
  padding: 10px;
}

.mood-boost-section h3 {
  color: #ff66cc;
  margin-bottom: 10px;
  font-size: 1.1rem;
  text-align: center;
}

.mood-boost-buttons {
  display: flex;
  justify-content: space-between;
  gap: 8px;
}

.mood-boost-button {
  flex: 1;
  padding: 10px;
  background: linear-gradient(to bottom, #ff66cc, #ff3399);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.mood-boost-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  background: linear-gradient(to bottom, #ff3399, #ff0066);
}

.mood-boost-button:active {
  transform: translateY(1px);
  box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.mood-boost-button:disabled {
  background: linear-gradient(to bottom, #ffb6db, #ffcce6);
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.cooldown-timer {
  font-size: 0.8rem;
  font-weight: normal;
  opacity: 0.8;
  margin-left: 5px;
}

.kick-chatter-btn {
  padding: 5px 10px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
  background: #ff9800;
  color: white;
}

.kick-chatter-btn:hover {
  background: #e68300;
}

.custom-chatters-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s, visibility 0.3s;
}

.custom-chatters-modal.active {
  opacity: 1;
  visibility: visible;
}

.modal-content {
  background: #1a2d3d;
  width: 90%;
  max-width: 600px;
  border-radius: 10px;
  padding: 20px;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
  max-height: 90vh;
  overflow-y: auto;
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 2px solid #ff66cc;
}

.modal-header h3 {
  color: #ff66cc;
  margin: 0;
}

.close-modal {
  background: none;
  border: none;
  color: #fff;
  font-size: 1.5rem;
  cursor: pointer;
}

.modal-tabs {
  display: flex;
  border-bottom: 1px solid #444;
  margin-bottom: 20px;
}

.modal-tab {
  padding: 10px 15px;
  background: transparent;
  border: none;
  color: #ccc;
  cursor: pointer;
  transition: all 0.3s;
}

.modal-tab.active {
  color: #ff66cc;
  border-bottom: 2px solid #ff66cc;
}

.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}

.custom-chatter-form {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.form-group label {
  color: #ddd;
  font-size: 0.9rem;
}

.form-group input, .form-group textarea {
  background: rgba(0, 0, 0, 0.2);
  border: 1px solid #444;
  border-radius: 4px;
  padding: 8px;
  color: white;
}

.form-group textarea {
  min-height: 80px;
  resize: vertical;
}

.chatter-image-container {
  display: flex;
  align-items: center;
  gap: 15px;
}

.chatter-image-preview {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  object-fit: cover;
  background-color: #333;
  border: 2px solid #555;
}

.chatter-image-upload {
  display: none;
}

.chatter-image-label {
  padding: 8px 12px;
  background: #333;
  color: white;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  border: 1px solid #555;
}

.color-preview {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  display: inline-block;
  margin-left: 10px;
  border: 1px solid #555;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
}

.form-actions button {
  padding: 8px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

.save-chatter-btn {
  background: #4CAF50;
  color: white;
}

.invited-chatters-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.invited-chatter {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  padding: 15px;
  display: flex;
  align-items: center;
  gap: 15px;
}

.invited-chatter-avatar {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  object-fit: cover;
}

.invited-chatter-info {
  flex: 1;
}

.invited-chatter-name {
  font-weight: bold;
  color: white;
  margin: 0 0 5px 0;
}

.invited-chatter-personality {
  font-size: 0.9rem;
  color: #ccc;
  margin: 0;
}

.invited-chatter-color {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  margin-left: 5px;
  display: inline-block;
}

.invited-chatter-actions {
  display: flex;
  gap: 5px;
}

.invite-chatter-btn, .remove-chatter-btn {
  padding: 5px 10px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
}

.invite-chatter-btn {
  background: #4CAF50;
  color: white;
}

.remove-chatter-btn {
  background: #f44336;
  color: white;
}

.no-chatters-message {
  text-align: center;
  color: #888;
  padding: 20px 0;
}

.options-panel {
  background: #1a2d3d;
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

#options-btn {
  background: #ff66cc;
  color: white;
  border: none;
  border-radius: 5px;
  padding: 8px 15px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s;
  margin-right: 10px;
}

#options-btn:hover {
  background: #ff33bb;
}

#options-menu {
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #444;
}

.option-group {
  margin-bottom: 15px;
}

.option-group h3 {
  color: #ff66cc;
  margin-bottom: 10px;
  font-size: 1.1rem;
}

.option-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.option-label {
  flex: 3;
  color: #ddd;
}

.option-control {
  flex: 2;
  display: flex;
  justify-content: flex-end;
}

.option-control input[type="range"] {
  width: 100%;
}

.range-value {
  width: 30px;
  text-align: right;
  margin-left: 10px;
  color: #ddd;
}

body.light-mode {
  background-color: #f5f5f5;
  color: #333;
}

body.light-mode .video-section, 
body.light-mode .reaction-section, 
body.light-mode .chat-section,
body.light-mode .character-customizer,
body.light-mode .streaming-panel,
body.light-mode .customizer-panel,
body.light-mode .options-panel,
body.light-mode .streaming-character,
body.light-mode .modal-content,
body.light-mode .chat-messages {
  background: #ffffff;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

body.light-mode .speech-bubble {
  background: #ffffff;
  border: 2px solid #ff66cc;
}

body.light-mode .speech-bubble p,
body.light-mode .chat-text {
  color: #333;
}

body.light-mode .modal-content {
  background: #ffffff;
}

body.light-mode #chat-input,
body.light-mode .customizer-field input, 
body.light-mode .customizer-field textarea,
body.light-mode .form-group input, 
body.light-mode .form-group textarea {
  background: rgba(0, 0, 0, 0.05);
  color: #333;
  border: 1px solid #ddd;
}

body.light-mode .invited-chatter,
body.light-mode .mood-image-selector,
body.light-mode .chat-messages {
  background: rgba(0, 0, 0, 0.05);
}
  </style>
</head>
<body>
  <!-- ‚ôªÔ∏è Cont√™iner principal de toda a aplica√ß√£o -->
  <div class="container">
    
    <!-- üêû Painel de Debug: Exibe informa√ß√µes para depura√ß√£o -->
    <div id="debug-panel" class="debug-panel">
      Informa√ß√µes de Debug: Aguardando an√°lise do v√≠deo...
      <button id="debug-toggle" class="debug-toggle">Ocultar Debug</button>
    </div>

    <!-- üó£Ô∏è Cabe√ßalho da p√°gina -->
    <header>
      <h1 id="page-title">Tempo de Rea√ß√£o do Blake</h1> <!-- T√≠tulo principal da p√°gina -->
      <div class="rainbow-flag">üè≥Ô∏è‚Äçüåà üê±</div> <!-- üè≥Ô∏è‚Äçüåà Emoji decorativo -->
    </header>
    
    <!-- ü§ñüõ†Ô∏è Se√ß√£o de Personaliza√ß√£o do Personagem e Op√ß√µes -->
    <div class="character-customizer">
      <!-- üîò Bot√µes de acesso r√°pido para op√ß√µes e pain√©is -->
      <div class="customizer-buttons">
        <button id="options-btn">Op√ß√µes</button>
        <button id="currently-streaming-btn">Em Transmiss√£o</button>
        <button id="toggle-customizer">Personalizar Personagem</button>
      </div>
      
      <!-- ‚öôÔ∏è Painel de Op√ß√µes (inicialmente oculto) -->
      <div id="options-menu" class="options-panel hidden">
        <div class="option-group">
          <h3>Configura√ß√µes do Reator</h3> <!-- Configura√ß√µes do "Reator" (Blake) -->
          <div class="option-item">
            <div class="option-label">M√°ximo de Tentativas</div>
            <div class="option-control">
              <input type="range" id="max-retries" min="1" max="10" value="3"> <!-- üì• Slider para tentativas m√°ximas -->
              <span class="range-value" id="max-retries-value">3</span>
            </div>
          </div>
          <div class="option-item">
            <div class="option-label">For√ßa da Resposta</div>
            <div class="option-control">
              <input type="range" id="response-strength" min="1" max="10" value="7"> <!-- üì• Slider para for√ßa da resposta -->
              <span class="range-value" id="response-strength-value">7</span>
            </div>
          </div>
        </div>
        
        <div class="option-group">
          <h3>Apar√™ncia</h3> <!-- Configura√ß√µes de Apar√™ncia -->
          <div class="option-item">
            <div class="option-label">Modo Escuro</div>
            <div class="option-control">
              <label class="toggle-switch">
                <input type="checkbox" id="theme-toggle" checked> <!-- üì• Toggle para modo escuro -->
                <span class="slider"></span>
              </label>
            </div>
          </div>
        </div>
      </div>
      
      <!-- üî¥ Painel de Personagens em Streaming (inicialmente oculto) -->
      <div id="streaming-panel" class="hidden">
        <div class="streaming-header">
          <h3>Personagens em Transmiss√£o</h3>
          <button id="save-to-stream">Salvar Personagem Atual na Transmiss√£o</button> <!-- üì• Salvar personagem atual -->
        </div>
        <div class="streaming-characters-container">
          <div id="streaming-characters">
            <!-- üîç Personagens em streaming ser√£o listados aqui -->
            <p class="loading-message">Carregando personagens...</p>
          </div>
        </div>
      </div>
      
      <!-- üé® Painel de Personaliza√ß√£o do Personagem (inicialmente oculto) -->
      <div id="customizer-panel" class="hidden">
        <div class="customizer-section">
          <h3>Configura√ß√µes do Personagem</h3> <!-- ü§ñ Configura√ß√µes do Personagem -->
          <div class="customizer-field">
            <label for="character-name">Nome:</label>
            <input type="text" id="character-name" placeholder="Blake"> <!-- üì• Nome do personagem -->
          </div>
          <div class="customizer-field">
            <label for="character-personality">Personalidade:</label>
            <textarea id="character-personality" placeholder="Um gato furry gay espirituoso e um pouco pregui√ßoso que ama conte√∫do LGBTQ+"></textarea> <!-- üì• Personalidade -->
          </div>
        </div>
        
        <div class="customizer-section">
          <h3>Imagens do Personagem</h3> <!-- ü§ñ Imagens de Humor do Personagem -->
          <div class="customizer-images">
            <!-- üñºÔ∏è Seletor de imagem para cada humor -->
            <div class="mood-image-selector" data-mood="normal">
              <p>Normal</p>
              <img src="Normal.png" alt="Normal"> <!-- ü§ñ Imagem padr√£o "Normal" -->
              <input type="file" id="normal-image" accept="image/*" class="mood-image-input"> <!-- üì• Upload de nova imagem -->
              <label for="normal-image" class="mood-image-label">Alterar</label>
            </div>
            <div class="mood-image-selector" data-mood="happy">
              <p>Feliz</p>
              <img src="Happy.png" alt="Feliz"> <!-- ü§ñ Imagem "Feliz" -->
              <input type="file" id="happy-image" accept="image/*" class="mood-image-input">
              <label for="happy-image" class="mood-image-label">Alterar</label>
            </div>
            <div class="mood-image-selector" data-mood="sad">
              <p>Triste</p>
              <img src="Reaction Thing that appears when NSFW or smth is shown idk.png" alt="Triste"> <!-- ü§ñ Imagem "Triste" -->
              <input type="file" id="sad-image" accept="image/*" class="mood-image-input">
              <label for="sad-image" class="mood-image-label">Alterar</label>
            </div>
            <div class="mood-image-selector" data-mood="angry">
              <p>Com Raiva</p>
              <img src="Anger.png" alt="Com Raiva"> <!-- ü§ñ Imagem "Com Raiva" -->
              <input type="file" id="angry-image" accept="image/*" class="mood-image-input">
              <label for="angry-image" class="mood-image-label">Alterar</label>
            </div>
            <div class="mood-image-selector" data-mood="shocked">
              <p>Chocado</p>
              <img src="Shocked.png" alt="Chocado"> <!-- ü§ñ Imagem "Chocado" -->
              <input type="file" id="shocked-image" accept="image/*" class="mood-image-input">
              <label for="shocked-image" class="mood-image-label">Alterar</label>
            </div>
            <div class="mood-image-selector" data-mood="traumatized">
              <p>Traumatizado</p>
              <img src="Bleeding/Trauma.png" alt="Traumatizado"> <!-- ü§ñ Imagem "Traumatizado" -->
              <input type="file" id="traumatized-image" accept="image/*" class="mood-image-input">
              <label for="traumatized-image" class="mood-image-label">Alterar</label>
            </div>
            <div class="mood-image-selector" data-mood="praying">
              <p>Rezando</p>
              <img src="Pray.png" alt="Rezando"> <!-- ü§ñ Imagem "Rezando" -->
              <input type="file" id="praying-image" accept="image/*" class="mood-image-input">
              <label for="praying-image" class="mood-image-label">Alterar</label>
            </div>
          </div>
        </div>
        
        <!-- üîò Bot√µes de A√ß√£o do Personalizador -->
        <div class="customizer-buttons">
          <button id="save-character">Salvar Personagem</button> <!-- Salvar altera√ß√µes -->
          <button id="reset-character">Restaurar Padr√£o</button> <!-- Resetar para padr√£o -->
        </div>
      </div>
    </div>
    
    <!-- ‚ôªÔ∏è Conte√∫do Principal: Se√ß√£o de V√≠deo e Se√ß√£o de Rea√ß√£o -->
    <div class="main-content">
      <!-- üé¨ Se√ß√£o para upload e visualiza√ß√£o de v√≠deo -->
      <div class="video-section">
        <div class="video-container">
          <input type="file" id="video-upload" accept="video/*"> <!-- üì• Input para upload de v√≠deo -->
          <label for="video-upload" id="upload-label">Arraste o v√≠deo aqui ou clique para enviar</label>
          <video id="video-player" controls></video> <!-- Player de v√≠deo -->
          <div class="input-area">
            <button id="unload-video">Remover V√≠deo</button> <!-- Descarregar v√≠deo -->
          </div>
        </div>
      </div>
      
      <!-- ü§ñ Se√ß√£o de Rea√ß√£o do Personagem -->
      <div class="reaction-section">
        <div class="character"> <!-- Cont√™iner do personagem e bal√£o de fala -->
          <img id="blake" src="Normal.png" alt="Blake"> <!-- Imagem do personagem Blake -->
          <div class="speech-bubble hidden" id="speech-bubble"> <!-- Bal√£o de fala (inicialmente oculto) -->
            <p id="reaction-text">Ol√°, sou o Blake! Mostre-me algo interessante!</p> <!-- Texto da rea√ß√£o -->
          </div>
        </div>
        <div class="controls"> <!-- Controles relacionados √† rea√ß√£o -->
          <div class="auto-reaction-toggle">
            <label class="toggle-switch">
              <input type="checkbox" id="auto-react-toggle"> <!-- üì• Toggle para rea√ß√µes autom√°ticas -->
              <span class="slider"></span>
            </label>
            <span>Rea√ß√µes Autom√°ticas</span>
          </div>
          <div class="mood-selection">
            <label for="mood-select">Definir Humor de <span class="character-name-span">Blake</span>:</label>
            <select id="mood-select"> <!-- üì• Sele√ß√£o manual de humor -->
              <option value="auto">Autom√°tico</option>
              <option value="normal">Normal</option>
              <option value="happy">Feliz</option>
              <option value="sad">Triste</option>
              <option value="angry">Com Raiva</option>
              <option value="shocked">Chocado</option>
              <option value="traumatized">Traumatizado</option>
              <option value="praying">Rezando</option>
            </select>
          </div>
          <div class="text-to-speech-toggle">
            <label class="toggle-switch">
              <input type="checkbox" id="tts-toggle"> <!-- üì• Toggle para Text-to-Speech (TTS) -->
              <span class="slider"></span>
            </label>
            <span>Texto para Fala</span>
          </div>
          <div class="reaction-indicator"> <!-- Indicador de humor -->
            <div class="mood-meter">
              <div class="mood-label">Humor de Blake:</div>
              <div id="mood-bar"> <!-- Barra de humor visual -->
                <div id="mood-meter-fill"></div>
              </div>
            </div>
            <div id="mood-value" class="mood-value">50%</div> <!-- Valor num√©rico do humor -->
          </div>
          <div class="mood-boost-section"> <!-- Se√ß√£o para "melhorar" o humor de Blake -->
            <h3>Ajude <span class="character-name-span">Blake</span> a se Sentir Melhor</h3>
            <div class="mood-boost-buttons">
              <button id="treat-button" class="mood-boost-button treat-button">Dar Guloseima <span id="treat-cooldown" class="cooldown-timer"></span></button> <!-- Dar um "agrado" -->
              <button id="pet-button" class="mood-boost-button pet-button">Fazer Carinho em <span class="character-name-span">Blake</span> <span id="pet-cooldown" class="cooldown-timer"></span></button> <!-- Fazer carinho -->
              <button id="compliment-button" class="mood-boost-button compliment-button">Elogiar <span id="compliment-cooldown" class="cooldown-timer"></span></button> <!-- Elogiar -->
            </div>
          </div>
          <button id="react-button" disabled>Obter Rea√ß√£o de Blake</button> <!-- Bot√£o para obter rea√ß√£o (inicialmente desabilitado) -->
        </div>
      </div>
    </div>
    
    <!-- üí¨ Se√ß√£o de Chat ao Vivo -->
    <div class="chat-section">
      <div class="chat-header">
        <h3>Chat ao Vivo</h3>
        <div class="chat-header-controls">
          <button id="add-chatter-btn" class="add-chatter-btn">Adicionar Participante</button> <!-- Adicionar participante customizado -->
          <span>üë• Online: <span id="viewers-count">4</span></span> <!-- Contador de espectadores -->
        </div>
      </div>
      <div class="chat-messages" id="chat-messages">
        <!-- üîç Mensagens do chat ser√£o adicionadas aqui dinamicamente -->
      </div>
      <div class="chat-input-area">
        <input type="text" id="chat-input" placeholder="Diga algo..."> <!-- üì• Campo para digitar mensagem -->
        <button id="send-chat">Enviar</button> <!-- Bot√£o para enviar mensagem -->
      </div>
    </div>
    
    <!-- üì¢ √Årea de Status da Aplica√ß√£o -->
    <div class="status-area">
      <p id="status-message">Blake est√° relaxando... Envie um v√≠deo para ver a rea√ß√£o dele!</p>
    </div>
  </div> <!-- Fim do .container principal -->
  
  <!-- üë§ Modal para Adicionar Participantes Customizados ao Chat -->
  <div id="custom-chatters-modal" class="custom-chatters-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Participantes Personalizados</h3>
        <button id="close-modal-btn" class="close-modal">√ó</button> <!-- Bot√£o para fechar o modal -->
      </div>
      
      <!-- Abas do Modal: Criar e Convidados -->
      <div class="modal-tabs">
        <button class="modal-tab active" data-tab="create-tab">Criar</button>
        <button class="modal-tab" data-tab="invited-tab">Participantes Convidados</button>
      </div>
      
      <!-- üìù Aba de Cria√ß√£o de Participante -->
      <div id="create-tab" class="tab-content active">
        <form id="chatter-form" class="custom-chatter-form"> <!-- üì• Formul√°rio para criar participante -->
          <div class="form-group">
            <label for="chatter-name">Nome:</label>
            <input type="text" id="chatter-name" required placeholder="Digite o nome do participante">
          </div>
          
          <div class="form-group">
            <label for="chatter-personality">Personalidade:</label>
            <textarea id="chatter-personality" required placeholder="Descreva a personalidade deste participante"></textarea>
          </div>
          
          <div class="form-group">
            <label for="chatter-image">Foto de Perfil:</label>
            <div class="chatter-image-container">
              <img id="chatter-image-preview" class="chatter-image-preview" src="https://ui-avatars.com/api/?name=Novo+Participante&background=random&color=fff" alt="Pr√©via do Participante"> <!-- Preview da imagem -->
              <input type="file" id="chatter-image-upload" class="chatter-image-upload" accept="image/*"> <!-- üì• Upload da imagem -->
              <label for="chatter-image-upload" class="chatter-image-label">Escolher Imagem</label>
            </div>
          </div>
          
          <div class="form-group">
            <label for="chatter-color">Cor do Nome de Usu√°rio:</label>
            <input type="color" id="chatter-color" value="#ff66cc"> <!-- üì• Seletor de cor para o nome -->
            <span id="color-preview" class="color-preview" style="background-color: #ff66cc"></span> <!-- Preview da cor -->
          </div>
          
          <div class="form-actions">
            <button type="submit" class="save-chatter-btn">Convidar para o Chat ao Vivo</button> <!-- Convidar para o chat -->
          </div>
        </form>
      </div>
      
      <!-- üìú Aba de Participantes Convidados -->
      <div id="invited-tab" class="tab-content">
        <div id="invited-chatters-list" class="invited-chatters-list">
          <!-- üîç Lista de participantes customizados convidados -->
          <p class="no-chatters-message">Nenhum participante personalizado ainda. Crie um na aba "Criar"!</p>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // Blake's Reaction Time - Main JavaScript

// üîç DOM Elements - Sele√ß√£o dos elementos HTML que ser√£o manipulados
let videoUpload = document.getElementById('video-upload');
let uploadLabel = document.getElementById('upload-label');
let videoPlayer = document.getElementById('video-player');
let blakeImage = document.getElementById('blake'); // ü§ñ Imagem do personagem principal
let speechBubble = document.getElementById('speech-bubble'); // üí¨ Bal√£o de fala
let reactionText = document.getElementById('reaction-text'); // üó£Ô∏è Texto dentro do bal√£o de fala
let reactButton = document.getElementById('react-button');
let statusMessage = document.getElementById('status-message'); // üì¢ Mensagem de status da aplica√ß√£o
let moodBar = document.getElementById('mood-bar'); // üå°Ô∏è Barra de humor visual
let moodMeterFill = document.getElementById('mood-meter-fill'); // Preenchimento da barra de humor
let moodValue = document.getElementById('mood-value'); // Valor percentual do humor
let autoReactToggle = document.getElementById('auto-react-toggle'); // ‚öôÔ∏è Toggle para rea√ß√µes autom√°ticas
let chatMessages = document.getElementById('chat-messages'); // √Årea de exibi√ß√£o das mensagens do chat
let chatInput = document.getElementById('chat-input'); // üì• Campo de entrada do chat
let sendChatButton = document.getElementById('send-chat'); // Bot√£o para enviar mensagem no chat
let unloadVideoButton = document.getElementById('unload-video');
let moodSelect = document.getElementById('mood-select'); // ‚öôÔ∏è Seletor manual de humor
let ttsToggle = document.getElementById('tts-toggle'); // ‚öôÔ∏è Toggle para Text-to-Speech
let debugPanel = document.getElementById('debug-panel'); // üêû Painel de debug
let debugToggle = document.getElementById('debug-toggle'); // Bot√£o para mostrar/ocultar debug
let toggleCustomizer = document.getElementById('toggle-customizer'); // Bot√£o para mostrar/ocultar personalizador
let customizerPanel = document.getElementById('customizer-panel'); // üé® Painel de personaliza√ß√£o
let characterName = document.getElementById('character-name'); // üì• Campo nome do personagem
let characterPersonality = document.getElementById('character-personality'); // üì• Campo personalidade
let saveCharacter = document.getElementById('save-character'); // Bot√£o salvar personagem
let resetCharacter = document.getElementById('reset-character'); // Bot√£o resetar personagem
let pageTitle = document.getElementById('page-title'); // T√≠tulo da p√°gina
let currentlyStreamingBtn = document.getElementById('currently-streaming-btn');
let streamingPanel = document.getElementById('streaming-panel');
let streamingList = document.getElementById('streaming-characters');
let saveToStreamBtn = document.getElementById('save-to-stream');
let treatButton = document.getElementById('treat-button'); // üç¨ Bot√£o dar guloseima
let petButton = document.getElementById('pet-button'); // üëã Bot√£o fazer carinho
let complimentButton = document.getElementById('compliment-button'); // ü•∞ Bot√£o elogiar
let addChatterBtn = document.getElementById('add-chatter-btn');
let customChattersModal = document.getElementById('custom-chatters-modal');
let closeModalBtn = document.getElementById('close-modal-btn');
let modalTabs = document.querySelectorAll('.modal-tab');
let tabContents = document.querySelectorAll('.tab-content');
let invitedChattersList = document.getElementById('invited-chatters-list');
let chatterForm = document.getElementById('chatter-form');
let chatterImagePreview = document.getElementById('chatter-image-preview');
let chatterImageUpload = document.getElementById('chatter-image-upload');
let chatterColorInput = document.getElementById('chatter-color');
let colorPreview = document.getElementById('color-preview');
let optionsBtn = document.getElementById('options-btn');
let optionsMenu = document.getElementById('options-menu');
let maxRetriesSlider = document.getElementById('max-retries');
let maxRetriesValue = document.getElementById('max-retries-value');
let themeToggle = document.getElementById('theme-toggle');
let responseStrengthSlider = document.getElementById('response-strength');
let responseStrengthValue = document.getElementById('response-strength-value');

// ‚öôÔ∏è Options settings - Configura√ß√µes da aplica√ß√£o
let options = {
  maxRetries: 3,
  darkMode: true,
  responseStrength: 7
};

// ü§ñ Custom character variables - Vari√°veis do personagem customiz√°vel
let currentCharacter = {
  name: 'Blake',
  personality: 'um gato furry gay espirituoso e um pouco pregui√ßoso que ama conte√∫do LGBTQ+',
  customImages: {},
  description: 'Um gato furry gay espirituoso com uma atitude pregui√ßosa, mas sagaz. Blake ama conte√∫do LGBTQ+ e n√£o tem medo de ser dram√°tico.'
};

// üî¥ New variable for character database - Vari√°vel para o "banco de dados" de personagens em streaming
let streamingCharacters = [];

// üó£Ô∏è Custom chatters variables - Vari√°veis para participantes customizados do chat
let customChatters = [];
let activeChatters = [];
let viewersCount = 4; // Contagem padr√£o de espectadores

// ‚è±Ô∏è Mood boost cooldown timers - Timers de recarga para melhoria de humor
let boostCooldowns = {
  treat: 0,
  pet: 0,
  compliment: 0
};

// üåê Initialize room for multiplayer functionality - Inicializa a sala para funcionalidade multiplayer (WebsimSocket)
const room = new WebsimSocket();
let streamingSubscription = null;

// üå°Ô∏è Current mood value (0-100) - Valor atual do humor
let currentMoodValue = 50;

// üìú Chat message history for idle chat - Hist√≥rico de mensagens do chat para conversas ociosas
let chatMessageHistory = [];
let lastChatReactionTime = 0;
let idleChatInterval = null;
let ambientChatInterval = null;

// üêû Function to update debug info text - Fun√ß√£o para atualizar texto de informa√ß√µes de debug
function updateDebugInfo(message) {
  if (debugPanel) {
    // üêû Atualizando o texto, mas mantendo a mensagem inicial se for o caso.
    debugPanel.textContent = message.includes("Waiting for video analysis...") ? message : `Info de Debug: ${message}`;
  }
}

// üêû Toggle debug panel visibility - Alterna visibilidade do painel de debug
function toggleDebugPanel() {
  if (debugPanel.style.display === 'none') {
    debugPanel.style.display = 'block';
    debugToggle.textContent = 'Ocultar Debug';
    localStorage.setItem('debugVisible', 'true');
  } else {
    debugPanel.style.display = 'none';
    debugToggle.textContent = 'Mostrar Debug';
    localStorage.setItem('debugVisible', 'false');
  }
}

// üå°Ô∏è Function to update mood meter based on reaction - Fun√ß√£o para atualizar o medidor de humor baseado na rea√ß√£o
function updateMoodMeter(mood) {
  // Define mood impact values
  const moodImpacts = {
    happy: 15,
    normal: 0,
    sad: -5,       // Reduced from -10
    angry: -10,    // Reduced from -20
    shocked: -3,   // Reduced from -5
    traumatized: -15, // Reduced from -30
    praying: -8    // Reduced from -15
  };
  
  // Only update mood if not in forced mood mode
  if (userSelectedMood === 'auto') {
    // Update current mood value
    currentMoodValue += moodImpacts[mood] || 0;
    
    // Clamp between 0 and 100
    currentMoodValue = Math.max(0, Math.min(100, currentMoodValue));
  }
  
  // Update visual elements
  if (moodMeterFill) {
    moodMeterFill.style.width = `${currentMoodValue}%`;
  }
  
  if (moodValue) {
    // Update with just percentage and color based on value
    moodValue.textContent = `${currentMoodValue}%`;
    moodValue.style.color = getMoodColor(currentMoodValue);
  }
  
  // Return mood position for marker
  return getMoodPosition(mood);
}

// üé® New function to get color for mood percentage - Fun√ß√£o para obter a cor baseada na porcentagem do humor
function getMoodColor(percentage) {
  if (percentage <= 0) return '#ff0000'; // Vermelho
  if (percentage <= 10) return '#ff4500'; // Vermelho Alaranjado
  if (percentage <= 20) return '#ffa500'; // Laranja
  if (percentage <= 30) return '#ffd700'; // Dourado
  if (percentage <= 40) return '#ffff00'; // Amarelo
  if (percentage <= 50) return '#00ff00'; // Verde (alterado para 50% ser totalmente verde)
  if (percentage <= 60) return '#00ffff'; // Ciano
  if (percentage <= 70) return '#0000ff'; // Azul
  if (percentage <= 80) return '#8a2be2'; // Azul Violeta
  if (percentage <= 90) return '#ff00ff'; // Magenta
  return '#ff00ff'; // Magenta
}

// üìç Calculate mood position for the mood meter marker - Calcula posi√ß√£o do marcador na barra de humor
function getMoodPosition(mood) {
  switch (mood) {
    case 'happy': return 80;
    case 'normal': return 50;
    case 'sad': return 30;
    case 'angry': return 10;
    case 'shocked': return 90;
    case 'traumatized': return 5;
    case 'praying': return 60;
    default: return 50;
  }
}

// ü§ñ Character mood states and corresponding images - Estados de humor e imagens correspondentes
// üí° Agora uma fun√ß√£o para suportar personagens customizados
function getCharacterMoods() {
  return {
    normal: {
      image: currentCharacter.customImages.normal || '/Normal.png',
      phrases: [
        `Estou pronto para assistir algo! Espero que n√£o seja chato... *mexe as orelhas*`,
        `Mostre-me algo legal, estou esperando~ *balan√ßa o rabo impacientemente*`,
        `Isso vai ser bom? Estou com muita pregui√ßa para me animar ainda. *boceja*`
      ]
    },
    happy: {
      image: currentCharacter.customImages.happy || '/Happy.png',
      phrases: [
        `MEU DEUS, eu amo isso! Totalmente a minha vibe! *ronrona alto*`,
        `SIM! √â para esse tipo de conte√∫do que eu me inscrevi! *rabo balan√ßando feliz*`,
        `Isso me traz tanta alegria! Nem consigo! *amassa o p√£ozinho feliz*`
      ]
    },
    sad: {
      image: currentCharacter.customImages.sad || '/Reaction Thing that appears when NSFW or smth is shown idk.png',
      phrases: [
        `Isso √©... realmente muito triste. Estou sentindo coisas... *orelhas caem*`,
        `Aff, por que de repente fiquei emotivo? Isso √© muito sentimental. *miado triste*`,
        `Eu n√£o esperava chorar hoje, mas aqui estamos. *enrola o rabo em si mesmo*`
      ]
    },
    angry: {
      image: currentCharacter.customImages.angry || '/Anger.png',
      phrases: [
        `Definitivamente N√ÉO. Quem aprovou isso? *silvo*`,
        `N√£o concordo com isso. Seriamente problem√°tico! *pelos eri√ßados*`,
        `A AUD√ÅCIA desse conte√∫do. Estou pistola! *rabo chicoteando de raiva*`
      ]
    },
    shocked: {
      image: currentCharacter.customImages.shocked || '/Shocked.png',
      phrases: [
        `QUE DIABOS eu acabei de assistir?! N√ÉO estava preparado! *pelos arrepiados*`,
        `Meu queixo caiu. Estou chocado! *garras cravam no assento*`,
        `N√£o acredito no que estou vendo! Isso √© real?! *orelhas achatadas*`
      ]
    },
    traumatized: {
      image: currentCharacter.customImages.traumatized || '/Bleeding/Trauma.png',
      phrases: [
        `Eu... acho que preciso de terapia depois disso. *bigodes tremendo*`,
        `Certas coisas n√£o podem ser desvistas. Esta √© uma delas. *se encolhe todo*`,
        `Minha alma acabou de sair do corpo. N√£o estou bem. *rabo entre as pernas*`
      ]
    },
    praying: {
      image: currentCharacter.customImages.praying || '/Pray.png',
      phrases: [
        `Queridos deuses gays, por favor, limpem meus olhos e minha timeline. *patinhas juntas*`,
        `Estou rezando por todos os envolvidos na cria√ß√£o disso. *miado reverente*`,
        `Isso √© um sinal de que preciso me reconectar com meu lado espiritual. *ronronar solene*`
      ]
    }
  };
}

// ü§ñ Set blakeMoods initially - Define os humores de Blake inicialmente
let blakeMoods = getCharacterMoods();

// üìú New reaction history feature - Nova funcionalidade de hist√≥rico de rea√ß√µes
let reactionHistory = [];
const MAX_HISTORY_LENGTH = 10; // üí° Limite m√°ximo de hist√≥rico
let retryAttempts = 0;

// üé¨ Current video state - Estado atual do v√≠deo
let videoLoaded = false;
let videoAnalyzed = false;
let currentVideoBlob = null;

// ‚öôÔ∏è Auto reaction variables - Vari√°veis para rea√ß√£o autom√°tica
let autoReactionEnabled = true;
let autoReactionInterval = null;
let lastReactionTime = 0;
let userSelectedMood = 'auto'; // Humor selecionado pelo usu√°rio (padr√£o: autom√°tico)
let ttsEnabled = false; // Text-to-Speech desabilitado por padr√£o

// üì• Handle file upload - Lida com upload de arquivo
videoUpload.addEventListener('change', (event) => {
  const file = event.target.files[0];
  if (file) {
    handleVideoFile(file);
  }
});

// üì• Handle drag and drop - Lida com arrastar e soltar
uploadLabel.addEventListener('dragover', (e) => {
  e.preventDefault();
  uploadLabel.style.borderColor = '#ff66cc';
  uploadLabel.style.backgroundColor = 'rgba(255, 102, 204, 0.1)';
});

uploadLabel.addEventListener('dragleave', () => {
  uploadLabel.style.borderColor = '#aaa';
  uploadLabel.style.backgroundColor = '';
});

uploadLabel.addEventListener('drop', (e) => {
  e.preventDefault();
  uploadLabel.style.borderColor = '#aaa';
  uploadLabel.style.backgroundColor = '';
  
  if (e.dataTransfer.files.length) {
    const file = e.dataTransfer.files[0];
    if (file.type.startsWith('video/')) {
      videoUpload.files = e.dataTransfer.files;
      handleVideoFile(file);
    } else {
      updateStatus('Apenas arquivos de v√≠deo s√£o suportados!', true);
    }
  }
});

// ‚ôªÔ∏è Process video file - Processa o arquivo de v√≠deo
function handleVideoFile(file) {
  currentVideoBlob = URL.createObjectURL(file);
  videoPlayer.src = currentVideoBlob;
  videoPlayer.style.display = 'block';
  uploadLabel.style.display = 'none';
  
  videoLoaded = true;
  videoAnalyzed = false;
  
  updateStatus(`V√≠deo "${file.name}" carregado! ${currentCharacter.name} reagir√° automaticamente.`);
  
  // Stop idle chat when video is loaded
  stopIdleChat();
  
  // Start auto reactions - always enabled on video load
  startAutoReactions();
  
  // Add event listeners to video player
  videoPlayer.addEventListener('play', handleVideoPlay);
  videoPlayer.addEventListener('ended', handleVideoEnd);
  videoPlayer.addEventListener('pause', handleVideoPause);
  
  // Trigger an immediate reaction
  setTimeout(() => {
    generateReaction();
  }, 500);
}

// üì¢ Update status message - Atualiza a mensagem de status
function updateStatus(message, isError = false) {
  statusMessage.textContent = message + (message.includes(currentCharacter.name) && !message.includes('*') ? ` *${currentCharacter.name} abana o rabo*` : '');
  statusMessage.style.color = isError ? '#ff0000' : (options.darkMode ? '#ccc' : '#666'); // Vermelho para erro, cinza para normal
}

// üóëÔ∏è Handle video unloading - Lida com a remo√ß√£o do v√≠deo
unloadVideoButton.addEventListener('click', () => {
  if (videoPlayer) {
    videoPlayer.src = '';
    videoPlayer.style.display = 'none';
    uploadLabel.style.display = 'block';
  }
  
  videoLoaded = false;
  videoAnalyzed = false;
  stopAutoReactions();
  stopAmbientChat();
  startIdleChat(); 
  speechBubble.classList.add('hidden');
  updateStatus(`${currentCharacter.name} est√° aguardando um novo v√≠deo...`);
});

// ‚öôÔ∏è Auto reaction toggle handler - Manipulador do toggle de rea√ß√£o autom√°tica
autoReactToggle.addEventListener('change', function() {
  autoReactionEnabled = this.checked;
  
  if (autoReactionEnabled && videoLoaded) {
    startAutoReactions();
    updateStatus(`Rea√ß√µes autom√°ticas de ${currentCharacter.name} ativadas! ${currentCharacter.name} reagir√° automaticamente.`);
  } else {
    stopAutoReactions();
    if (this.checked) {
      updateStatus(`Rea√ß√µes autom√°ticas de ${currentCharacter.name} ativadas, mas nenhum v√≠deo carregado ainda.`);
    } else {
      updateStatus(`Rea√ß√µes autom√°ticas de ${currentCharacter.name} desativadas. ${currentCharacter.name} n√£o reagir√° automaticamente.`);
    }
  }
});

// ‚öôÔ∏è Mood selection handler - Manipulador da sele√ß√£o de humor
moodSelect.addEventListener('change', function() {
  userSelectedMood = this.value;
  
  if (userSelectedMood !== 'auto') {
    const mood = userSelectedMood;
    const moodPosition = getMoodPosition(mood);
    
    // ü§ñ Gerar rea√ß√£o da IA com o humor selecionado
    generateAIReaction(mood, null, "").then(reactionTextContent => { // Passa null para frameDataUrl e texto extra√≠do vazio
      displayBlakeReaction({
        mood: mood,
        text: reactionTextContent,
        moodPosition: moodPosition
      });
    });
  }
  
  updateStatus(userSelectedMood === 'auto' ? 
    `${currentCharacter.name} reagir√° com base no conte√∫do do v√≠deo` : 
    `Humor de ${currentCharacter.name} definido para ${userSelectedMood}`);
});

// ‚öôÔ∏è Text-to-speech toggle handler - Manipulador do toggle de TTS
ttsToggle.addEventListener('change', function() {
  ttsEnabled = this.checked;
  updateStatus(ttsEnabled ? 
    `Texto para Fala ativado. ${currentCharacter.name} agora falar√° suas rea√ß√µes.` : 
    "Texto para Fala desativado.");
});

// üó£Ô∏è Speak text using speech synthesis - Fala o texto usando s√≠ntese de voz
function speakText(text) {
  if (!ttsEnabled || !window.speechSynthesis) return;
  
  window.speechSynthesis.cancel(); // Cancela falas anteriores
  
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.pitch = 1.1; 
  utterance.rate = 1.1; 
  utterance.lang = 'pt-BR'; // üí° Define o idioma para portugu√™s do Brasil
  
  const voices = window.speechSynthesis.getVoices();
  // üí° Tenta encontrar uma voz masculina em portugu√™s ou ingl√™s como fallback
  const preferredVoices = voices.filter(voice => 
    (voice.name.includes('Male') || voice.name.includes('Masculina') || voice.lang.startsWith('pt')) && voice.lang.startsWith('pt') || // Prioriza pt-BR masculina
    voice.name.includes('Male') && voice.lang.startsWith('en-US') // Fallback para en-US masculina
  );
  
  if (preferredVoices.length > 0) {
    utterance.voice = preferredVoices[0];
  } else if (voices.length > 0) {
    // Fallback para a primeira voz pt-BR dispon√≠vel, ou qualquer voz se n√£o houver pt-BR
    const ptVoices = voices.filter(voice => voice.lang.startsWith('pt'));
    utterance.voice = ptVoices.length > 0 ? ptVoices[0] : voices[0];
  }
  
  window.speechSynthesis.speak(utterance);
}

// ‚ñ∂Ô∏è Start automatic reactions - Inicia rea√ß√µes autom√°ticas
function startAutoReactions() {
  stopAutoReactions(); 
  generateReaction(); // Gera uma rea√ß√£o imediata
  autoReactionInterval = setInterval(() => {
    if (videoPlayer.currentTime > 0 && !videoPlayer.paused && !videoPlayer.ended) {
      generateReaction();
    }
  }, 5000 + Math.random() * 5000); // Intervalo aleat√≥rio entre 5 e 10 segundos
}

// ‚èπÔ∏è Stop automatic reactions - Para rea√ß√µes autom√°ticas
function stopAutoReactions() {
  if (autoReactionInterval) {
    clearInterval(autoReactionInterval);
    autoReactionInterval = null;
  }
}

// üß† Simulate AI video analysis - Simula an√°lise de v√≠deo pela IA
async function analyzeVideoWithAI() {
  try {
    let randomMood;
    if (userSelectedMood !== 'auto') {
      randomMood = userSelectedMood;
    } else {
      const moodKeys = Object.keys(blakeMoods);
      randomMood = moodKeys[Math.floor(Math.random() * moodKeys.length)];
    }
    
    let moodPosition = getMoodPosition(randomMood);
    moodPosition += Math.floor(Math.random() * 20) - 10; // Pequena varia√ß√£o
    moodPosition = Math.max(0, Math.min(100, moodPosition)); // Garante entre 0-100
    
    let frameDataUrl = null;
    let extractedText = "";
    if (videoPlayer.videoWidth && videoPlayer.videoHeight && videoPlayer.currentTime > 0) { // Se o v√≠deo tem dimens√µes (est√° carregado) e n√£o est√° no in√≠cio
      const canvas = document.createElement('canvas');
      canvas.width = videoPlayer.videoWidth;
      canvas.height = videoPlayer.videoHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height); // Desenha o frame atual no canvas
      frameDataUrl = canvas.toDataURL('image/jpeg'); // Converte para Data URL
      
      // ü§ñ Chama a IA para descrever o frame e extrair texto (em paralelo)
      const [description, extractedTextResult] = await Promise.all([
        describeFrame(frameDataUrl),
        extractTextFromFrame(frameDataUrl)
      ]);
      extractedText = extractedTextResult;
      
      updateDebugInfo(`üß† Analisando Frame:\n${description}`);
      
      // ü§ñ Gera a rea√ß√£o da IA
      let customReaction = await generateAIReaction(randomMood, frameDataUrl, extractedText);
      
      // Se texto foi extra√≠do, dispara mensagens de chat da IA
      if (extractedText && extractedText.trim() !== "") {
        triggerAIChatMessages(extractedText);
      }
      
      return {
        mood: randomMood,
        text: customReaction,
        moodPosition: moodPosition
      };
    }
    // ‚ö†Ô∏è Se n√£o h√° v√≠deo (ou dimens√µes), retorna um erro ou estado padr√£o.
    // No c√≥digo original, ele prosseguiria e generateAIReaction lidaria com frameDataUrl nulo.
    // Vamos manter essa l√≥gica.
    const fallbackReactionText = await generateAIReaction(randomMood, null, "");
     return {
        mood: randomMood,
        text: fallbackReactionText,
        moodPosition: moodPosition
    };

  } catch (error) {
    console.error('Erro na an√°lise pela IA:', error);
    updateDebugInfo(`Erro na an√°lise: ${error.message}`);
    // Retornar um objeto de rea√ß√£o de fallback em caso de erro.
     const moodKeys = Object.keys(blakeMoods);
     const fallbackMood = moodKeys[Math.floor(Math.random() * moodKeys.length)];
     const fallbackPhrases = blakeMoods[fallbackMood].phrases;
     const fallbackText = fallbackPhrases[Math.floor(Math.random() * fallbackPhrases.length)];
     return {
        mood: fallbackMood,
        text: `Oops, algo deu errado com minha an√°lise! Mas estou me sentindo ${fallbackMood}. ${fallbackText}`,
        moodPosition: getMoodPosition(fallbackMood)
    };
  }
}

// ü§ñ Updated function to extract text from video frame - Fun√ß√£o para extrair texto do frame
async function extractTextFromFrame(frameDataUrl) {
  try {
    const completion = await websim.chat.completions.create({
      messages: [
        {
          role: "system",
          content: "Voc√™ √© um assistente de extra√ß√£o de texto. Sua tarefa √© extrair e retornar apenas o texto vis√≠vel da imagem fornecida. Se n√£o houver texto, retorne uma string vazia."
        },
        {
          role: "user",
          content: [
            {
              type: "image_url",
              image_url: { url: frameDataUrl }
            }
          ]
        }
      ]
    });
    let extracted = completion.content.trim();
    return extracted;
  } catch (error) {
    console.error('Error extracting text from frame:', error);
    return ""; // Retorna string vazia em caso de erro
  }
}

// ‚ú® New function to describe the frame using AI - Nova fun√ß√£o para descrever o frame usando IA
async function describeFrame(frameDataUrl) {
  try {
    const completion = await websim.chat.completions.create({
      messages: [
        {
          role: "system",
          content: "You are an image description assistant. Describe the provided image in a concise and informative way, focusing on the main elements and actions."
        },
        {
          role: "user",
          content: [
            {
              type: "image_url",
              image_url: { url: frameDataUrl }
            }
          ]
        }
      ]
    });
    return completion.content.trim();
  } catch (error) {
    console.error('Error describing frame:', error);
    return "Descri√ß√£o do frame indispon√≠vel.";
  }
}

// ü§ñ New function to generate AI reaction based on mood, frame, and text - Nova fun√ß√£o para gerar rea√ß√£o da IA
async function generateAIReaction(mood, frameDataUrl, extractedText) {
  try {
    // üõ†Ô∏è Ajuste da for√ßa da resposta
    const strengthAdjustment = (options.responseStrength - 5) * 0.1; // De -0.4 a +0.5
    const sassLevel = Math.max(0.1, Math.min(1.0, 0.5 + strengthAdjustment)); // Garante entre 0.1 e 1.0

    let systemPromptContent = `Voc√™ √© ${currentCharacter.name}, ${currentCharacter.personality}. 
      Voc√™ est√° assistindo a um v√≠deo e precisa reagir. 
      Seu humor atual √©: ${mood}. 
      Seu n√≠vel de "atrevimento/sarcasmo" √© ${sassLevel.toFixed(1)} (0.1 = muito leve, 1.0 = muito atrevido).
      Gere uma rea√ß√£o curta e espirituosa (1-2 frases) no estilo casual de m√≠dia social, com maneirismos felinos e coment√°rios ocasionais com tema LGBTQ+.
      Se houver texto no v√≠deo, comente sobre ele diretamente.
      Responda em portugu√™s brasileiro.`;

    let userPromptContent = [];

    if (frameDataUrl) {
      const textForPrompt = extractedText ? 
        `O v√≠deo cont√©m este texto: "${extractedText}". Reaja tanto ao conte√∫do visual quanto ao texto.` : 
        "Qual √© a sua rea√ß√£o a este frame do v√≠deo?";
      userPromptContent.push({ type: "text", text: textForPrompt });
      userPromptContent.push({ type: "image_url", image_url: { url: frameDataUrl } });
    } else {
      userPromptContent.push({ type: "text", text: "Como voc√™ est√° se sentindo agora ou o que voc√™ diria?" });
    }
    
    const completion = await websim.chat.completions.create({
      messages: [
        { role: "system", content: systemPromptContent },
        { role: "user", content: userPromptContent }
      ]
    });
    
    let reaction = completion.content.trim();
    return reaction;

  } catch (error) {
    console.error('Erro ao gerar rea√ß√£o da IA:', error);
    updateDebugInfo(`Erro na rea√ß√£o da IA: ${error.message}`);
    const phrases = blakeMoods[mood]?.phrases || blakeMoods.normal.phrases; // Fallback para frases normais
    let fallbackReaction = phrases[Math.floor(Math.random() * phrases.length)];
    return fallbackReaction;
  }
}

// ‚ú® Display Blake's reaction on the UI - Exibe a rea√ß√£o de Blake na UI
function displayBlakeReaction(reactionDetails) {
  const { mood, text, moodPosition } = reactionDetails;
  
  if (blakeImage && blakeMoods[mood]) {
    blakeImage.src = blakeMoods[mood].image;
    blakeImage.alt = `${currentCharacter.name} - ${mood}`;
  }
  
  if (reactionText) {
    reactionText.textContent = text;
  }
  
  if (speechBubble) {
    speechBubble.classList.remove('hidden');
  }
  
  updateMoodMeter(mood); // Atualiza o medidor de humor
  
  // üí¨ Adiciona a rea√ß√£o ao chat como uma mensagem do personagem
  addChatMessage(currentCharacter.name, text, '#ff66cc', blakeMoods[mood]?.image || blakeMoods.normal.image);
  
  // üó£Ô∏è Fala a rea√ß√£o se TTS estiver habilitado
  speakText(text);
}

// üîÑ Generate reaction and update UI - Gera rea√ß√£o e atualiza UI
async function generateReaction() {
  if (Date.now() - lastReactionTime < 3000 && userSelectedMood === 'auto') return; // Evita rea√ß√µes muito r√°pidas
  
  lastReactionTime = Date.now();
  
  try {
    updateStatus(`${currentCharacter.name} est√° pensando... *orelhas se mexem*`);
    const reactionDetails = await analyzeVideoWithAI();
    displayBlakeReaction(reactionDetails);
    
    // üìú Adiciona ao hist√≥rico de rea√ß√µes (se for relevante e diferente da √∫ltima)
    if (reactionHistory.length === 0 || reactionHistory[reactionHistory.length - 1].text !== reactionDetails.text) {
      reactionHistory.push(reactionDetails);
      if (reactionHistory.length > MAX_HISTORY_LENGTH) {
        reactionHistory.shift(); // Mant√©m o hist√≥rico no tamanho m√°ximo
      }
    }
    
    retryAttempts = 0; // Reseta tentativas de retry em sucesso
    
  } catch (error) {
    console.error('Falha ao gerar rea√ß√£o:', error);
    retryAttempts++;
    
    if (retryAttempts <= options.maxRetries) {
      updateStatus(`Houve um problema ao obter a rea√ß√£o de ${currentCharacter.name}. Tentando novamente (${retryAttempts}/${options.maxRetries})... *${currentCharacter.name} franze o nariz*`);
      setTimeout(generateReaction, 2000 * retryAttempts); // Tenta novamente com delay crescente
    } else {
      updateStatus(`N√£o foi poss√≠vel obter uma rea√ß√£o de ${currentCharacter.name} ap√≥s ${options.maxRetries} tentativas. ${currentCharacter.name} parece confuso. *${currentCharacter.name} inclina a cabe√ßa*`);
      // Usa uma rea√ß√£o de fallback se a IA falhar consistentemente
      const fallbackMood = 'sad';
      const fallbackPhrases = blakeMoods[fallbackMood].phrases;
      const fallbackText = fallbackPhrases[Math.floor(Math.random() * fallbackPhrases.length)];
      displayBlakeReaction({
        mood: fallbackMood,
        text: fallbackText,
        moodPosition: getMoodPosition(fallbackMood)
      });
      retryAttempts = 0; // Reseta para futuras tentativas manuais ou autom√°ticas
    }
  }
}

// ‚ñ∂Ô∏è Handle video play - Lida com o play do v√≠deo
function handleVideoPlay() {
  updateStatus(`${currentCharacter.name} est√° assistindo ao v√≠deo...`);
  if (autoReactionEnabled) {
    startAutoReactions();
  }
}

// ‚èπÔ∏è Handle video end - Lida com o fim do v√≠deo
function handleVideoEnd() {
  updateStatus(`O v√≠deo terminou. ${currentCharacter.name} aguarda sua pr√≥xima aventura! *${currentCharacter.name} se espregui√ßa*`);
  stopAutoReactions();
  startIdleChat(); // Reinicia chat ocioso
  
  // Rea√ß√£o final
  setTimeout(async () => {
    const finalMood = currentMoodValue > 70 ? 'happy' : (currentMoodValue < 30 ? 'sad' : 'normal');
    const reactionTextContent = await generateAIReaction(finalMood, null, "O v√≠deo acabou. Qual sua impress√£o final?");
    displayBlakeReaction({
        mood: finalMood,
        text: reactionTextContent,
        moodPosition: getMoodPosition(finalMood)
    });
  }, 1000);
}

// ‚è∏Ô∏è Handle video pause - Lida com a pausa do v√≠deo
function handleVideoPause() {
  updateStatus(`V√≠deo pausado. ${currentCharacter.name} est√° esperando... *${currentCharacter.name} boceja*`);
  stopAutoReactions(); // Pausa rea√ß√µes autom√°ticas tamb√©m
}

// --- üí¨ Chat Functionality ---

// ‚ú® Add a message to the chat UI - Adiciona uma mensagem √† UI do chat
function addChatMessage(username, message, userColor = '#ffffff', avatarSrc = null, isUser = false) {
  const messageElement = document.createElement('div');
  messageElement.classList.add('chat-message');
  if (isUser) {
    messageElement.classList.add('message-user');
  } else {
    // Adiciona classe baseada no nome para estiliza√ß√£o (opcional)
    messageElement.classList.add(`message-${username.toLowerCase().replace(/\s+/g, '-')}`);
  }

  let avatarHTML = '';
  if (avatarSrc) {
    avatarHTML = `<img src="${avatarSrc}" alt="${username}" class="chat-avatar">`;
  } else {
    // Avatar padr√£o baseado nas iniciais se n√£o houver imagem
    const initials = username.substring(0, 2).toUpperCase();
    avatarHTML = `<img src="https://ui-avatars.com/api/?name=${encodeURIComponent(username)}&background=random&color=fff&size=24" alt="${username}" class="chat-avatar">`;
  }

  messageElement.innerHTML = `
    ${avatarHTML}
    <div>
      <span class="chat-username" style="color: ${userColor};">${username}:</span>
      <span class="chat-text">${message}</span>
    </div>
  `;
  chatMessages.appendChild(messageElement);
  chatMessages.scrollTop = chatMessages.scrollHeight; // Auto-scroll para a √∫ltima mensagem

  // Adiciona ao hist√≥rico para o chat ocioso da IA
  if (username !== currentCharacter.name) { // N√£o adiciona as pr√≥prias mensagens do Blake ao hist√≥rico para ele reagir
    chatMessageHistory.push({ username, message });
    if (chatMessageHistory.length > 20) { // Limita o hist√≥rico
        chatMessageHistory.shift();
    }
  }
}

// ‚ñ∂Ô∏è Event listener for sending chat messages - Listener para enviar mensagens no chat
sendChatButton.addEventListener('click', sendUserChatMessage);
chatInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    sendUserChatMessage();
  }
});

// üó£Ô∏è Function to send user chat message - Fun√ß√£o para enviar mensagem do usu√°rio no chat
async function sendUserChatMessage() {
  const messageText = chatInput.value.trim();
  if (messageText) {
    // üë§ Obter informa√ß√µes do usu√°rio atual (simulado aqui, idealmente viria do Websim)
    const currentUser = await window.websim.getUser() || { username: "Voc√™", avatar_url: null };
    const username = currentUser.username;
    const avatar = currentUser.avatar_url || `https://images.websim.ai/avatar/${username}`;

    addChatMessage(username, messageText, '#ff66cc', avatar, true); // Cor padr√£o para o usu√°rio, isUser = true
    chatInput.value = ''; // Limpa o input

    // ü§ñ Trigger AI reaction to user's message if idle chat is active
    if (idleChatInterval || ambientChatInterval) {
      lastChatReactionTime = Date.now() - 20000; // Faz a IA reagir mais r√°pido √† mensagem do usu√°rio
    }
  }
}

// ü§ñ Function to generate and add an AI chat message - Fun√ß√£o para gerar e adicionar mensagem de IA no chat
async function generateIdleChatMessage() {
    if (Date.now() - lastChatReactionTime < 30000 && !videoLoaded) return; // Evita spam de chat ocioso (30s)
    if (videoLoaded && (videoPlayer.currentTime > 0 && !videoPlayer.paused)) return; // N√£o gera se v√≠deo estiver tocando
    
    lastChatReactionTime = Date.now();

    try {
        // ü§ñ Decide se Blake ou um chatter customizado vai falar
        const participants = [currentCharacter.name, ...activeChatters.map(c => c.name)];
        const speakerName = participants[Math.floor(Math.random() * participants.length)];
        
        let speakerPersonality = currentCharacter.personality;
        let speakerAvatar = blakeMoods.normal.image;
        let speakerColor = '#ff66cc';

        if (speakerName !== currentCharacter.name) {
            const chatter = activeChatters.find(c => c.name === speakerName);
            if (chatter) {
                speakerPersonality = chatter.personality;
                speakerAvatar = chatter.image || `https://ui-avatars.com/api/?name=${encodeURIComponent(chatter.name)}&background=random&color=fff&size=24`;
                speakerColor = chatter.color || '#aaa';
            }
        }
        
        let systemPromptContent = `Voc√™ √© ${speakerName}, ${speakerPersonality}.
            Voc√™ est√° no chat de uma livestream. 
            Baseado no hist√≥rico recente do chat, gere uma mensagem curta e casual (1-2 frases) que voc√™ postaria.
            Mantenha o tom apropriado e natural para um chat de livestream.
            Se o hist√≥rico estiver vazio, apenas diga algo aleat√≥rio ou cumprimente.
            Responda em portugu√™s brasileiro. N√£o use hashtags ou markdown.`;

        let userPromptContent = "Hist√≥rico do chat (mais recentes primeiro):\n";
        if (chatMessageHistory.length > 0) {
            // Pega as √∫ltimas 5 mensagens
            const recentMessages = chatMessageHistory.slice(-5).reverse();
            recentMessages.forEach(msg => {
                userPromptContent += `${msg.username}: ${msg.message}\n`;
            });
        } else {
            userPromptContent += "(Nenhuma mensagem recente no chat)\n";
        }
        userPromptContent += `\nO que ${speakerName} diria agora?`;

        const completion = await websim.chat.completions.create({
            messages: [
                { role: "system", content: systemPromptContent },
                { role: "user", content: userPromptContent }
            ]
        });
        let chatResponse = completion.content.trim();

        if (chatResponse) {
             addChatMessage(speakerName, chatResponse, speakerColor, speakerAvatar);
        }

    } catch (error) {
        console.error('Erro ao gerar mensagem de chat ocioso:', error);
        // Fallback simples se a IA falhar
        if (Math.random() < 0.2) { // Blake fala com menos frequ√™ncia no fallback
             const phrases = ["Hmm...", "*bocejo*", "Algu√©m a√≠?", "Que t√©dio...", "Mostra um v√≠deo a√≠, pls!"];
             addChatMessage(currentCharacter.name, phrases[Math.floor(Math.random() * phrases.length)], '#ff66cc', blakeMoods.normal.image);
        }
    }
}

// ü§ñ Function to trigger AI chat messages based on extracted text - Fun√ß√£o para disparar mensagens de chat da IA baseadas em texto extra√≠do
async function triggerAIChatMessages(extractedText) {
  if (!extractedText || extractedText.trim() === "") return;

  try {
    const chatters = activeChatters.length > 0 ? activeChatters : [
        { name: 'Zangos', personality: 'engra√ßado e um pouco ca√≥tico', color: '#ff5722' },
        { name: 'Connie', personality: 'anal√≠tica e curiosa', color: '#2196f3' },
        { name: 'Beary', personality: 'c√≠nico mas com um bom cora√ß√£o', color: '#8bc34a' }
    ];
    
    // Seleciona 1 ou 2 chatters aleat√≥rios para comentar
    const numChattersToComment = Math.random() < 0.6 ? 1 : (activeChatters.length > 1 ? 2 : activeChatters.length);
    const selectedChatters = [];
    const availableChatters = [...chatters]; // Copia para poder remover

    for (let i = 0; i < numChattersToComment && availableChatters.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * availableChatters.length);
        selectedChatters.push(availableChatters.splice(randomIndex, 1)[0]);
    }

    for (const chatter of selectedChatters) {
      const systemPromptContent = `Voc√™ √© ${chatter.name}, um espectador ${chatter.personality}.
        Voc√™ est√° assistindo a uma livestream onde o texto "${extractedText}" acabou de aparecer no v√≠deo.
        Gere uma rea√ß√£o curta e casual (1 frase) a este texto, como se estivesse digitando no chat.
        Responda em portugu√™s brasileiro. N√£o use hashtags ou markdown.`;

      const completion = await websim.chat.completions.create({
        messages: [
          { role: "system", content: systemPromptContent },
          { role: "user", content: `O que ${chatter.name} diria sobre "${extractedText}"?` }
        ]
      });
      let chatterReaction = completion.content.trim();
      if (chatterReaction) {
        addChatMessage(chatter.name, chatterReaction, chatter.color, chatter.image || `https://ui-avatars.com/api/?name=${encodeURIComponent(chatter.name)}&background=random&color=fff&size=24`);
        await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000)); // Pequeno delay
      }
    }
  } catch (error) {
    console.error("Erro ao gerar coment√°rios da IA sobre o texto do v√≠deo:", error);
  }
}

// üí¨ Start idle chat - Inicia chat ocioso
function startIdleChat() {
  stopIdleChat(); // Para qualquer chat ocioso existente
  if (!videoLoaded) { // S√≥ inicia se n√£o houver v√≠deo carregado
    idleChatInterval = setInterval(generateIdleChatMessage, 20000 + Math.random() * 10000); // Entre 20-30 segundos
  }
}

// üí¨ Stop idle chat - Para chat ocioso
function stopIdleChat() {
  if (idleChatInterval) {
    clearInterval(idleChatInterval);
    idleChatInterval = null;
  }
}

// üí¨ Start ambient chat (more frequent when video is paused but loaded)
function startAmbientChat() {
    stopAmbientChat();
    if (videoLoaded && videoPlayer.paused) {
        ambientChatInterval = setInterval(generateIdleChatMessage, 15000 + Math.random() * 10000); // 15-25s
    }
}

// üí¨ Stop ambient chat
function stopAmbientChat() {
    if (ambientChatInterval) {
        clearInterval(ambientChatInterval);
        ambientChatInterval = null;
    }
}

// --- ‚ú® Character Customization ---
// ‚ú® Load saved character from localStorage - Carrega personagem salvo do localStorage
function loadSavedCharacter() {
  const saved = localStorage.getItem('blakeReactionCharacter');
  if (saved) {
    try {
      const parsedCharacter = JSON.parse(saved);
      // üí° Valida√ß√£o b√°sica para garantir que os campos esperados existam
      if (parsedCharacter.name && parsedCharacter.personality) {
        currentCharacter = parsedCharacter;
        // Garante que customImages exista
        if (!currentCharacter.customImages) {
          currentCharacter.customImages = {};
        }
      } else {
        console.warn("Personagem salvo inv√°lido, usando padr√£o.");
        saveCurrentCharacter(); // Salva o padr√£o se o salvo for inv√°lido
      }
    } catch (e) {
      console.error("Erro ao carregar personagem salvo, usando padr√£o:", e);
      saveCurrentCharacter(); // Salva o padr√£o em caso de erro de parse
    }
  }
  applyCharacterToUI();
}

// ‚ú® Save current character to localStorage - Salva personagem atual no localStorage
function saveCurrentCharacter() {
  localStorage.setItem('blakeReactionCharacter', JSON.stringify(currentCharacter));
}

// ‚ú® Apply character data to UI - Aplica dados do personagem na UI
function applyCharacterToUI() {
  if (characterName) characterName.value = currentCharacter.name;
  if (characterPersonality) characterPersonality.value = currentCharacter.personality;
  if (pageTitle) pageTitle.textContent = `Tempo de Rea√ß√£o de ${currentCharacter.name}`;
  
  document.querySelectorAll('.character-name-span').forEach(span => {
    span.textContent = currentCharacter.name;
  });

  blakeMoods = getCharacterMoods(); // Atualiza os humores com as novas imagens

  // Atualiza as imagens de preview no personalizador
  document.querySelectorAll('.mood-image-selector').forEach(selector => {
    const mood = selector.dataset.mood;
    const imgElement = selector.querySelector('img');
    if (imgElement && blakeMoods[mood]) {
      imgElement.src = blakeMoods[mood].image;
    }
  });

  // Atualiza a imagem principal do Blake se ele estiver vis√≠vel e n√£o houver v√≠deo
  if (blakeImage && !videoLoaded) {
     const currentSelectedMood = moodSelect.value !== 'auto' ? moodSelect.value : 'normal';
     blakeImage.src = blakeMoods[currentSelectedMood]?.image || blakeMoods.normal.image;
  }
}

// ‚ú® Handle mood image upload - Lida com upload de imagem de humor
async function handleMoodImageUpload(event) {
  const input = event.target;
  const mood = input.closest('.mood-image-selector').dataset.mood;
  const file = input.files[0];

  if (file && mood) {
    try {
      updateStatus(`Enviando imagem para humor "${mood}"...`);
      const imageUrl = await websim.upload(file); // Faz upload e obt√©m a URL
      
      currentCharacter.customImages[mood] = imageUrl;
      saveCurrentCharacter();
      applyCharacterToUI(); // Atualiza a UI com a nova imagem
      updateStatus(`Imagem para humor "${mood}" atualizada!`);
    } catch (error) {
      console.error(`Erro ao enviar imagem para ${mood}:`, error);
      updateStatus(`Erro ao enviar imagem para ${mood}. Tente novamente.`, true);
    }
  }
}

// ‚ú® Save character button listener - Listener do bot√£o salvar personagem
saveCharacter.addEventListener('click', () => {
  currentCharacter.name = characterName.value.trim() || 'Blake';
  currentCharacter.personality = characterPersonality.value.trim() || 'Um gato furry gay espirituoso...';
  // Descri√ß√£o pode ser atualizada aqui se houver um campo para ela
  // currentCharacter.description = document.getElementById('character-description').value;

  saveCurrentCharacter();
  applyCharacterToUI();
  updateStatus(`Personagem "${currentCharacter.name}" salvo com sucesso!`);
  
  // üí° Opcional: Fechar o painel de personaliza√ß√£o ap√≥s salvar
  // customizerPanel.classList.add('hidden');
  // toggleCustomizer.textContent = 'Personalizar Personagem';
});

// ‚ú® Reset character button listener - Listener do bot√£o resetar personagem
resetCharacter.addEventListener('click', () => {
  if (confirm(`Tem certeza que deseja restaurar ${currentCharacter.name} para as configura√ß√µes padr√£o? Todas as imagens personalizadas ser√£o removidas.`)) {
    currentCharacter = {
      name: 'Blake',
      personality: 'um gato furry gay espirituoso e um pouco pregui√ßoso que ama conte√∫do LGBTQ+',
      customImages: {},
      description: 'Um gato furry gay espirituoso com uma atitude pregui√ßosa, mas sagaz. Blake ama conte√∫do LGBTQ+ e n√£o tem medo de ser dram√°tico.'
    };
    saveCurrentCharacter();
    applyCharacterToUI();
    updateStatus(`Personagem "${currentCharacter.name}" restaurado para o padr√£o.`);
  }
});

// ‚ú® Function to update character name spans - Fun√ß√£o para atualizar spans com nome do personagem
function updateCharacterNameSpans() {
  document.querySelectorAll('.character-name-span').forEach(span => {
    span.textContent = currentCharacter.name;
  });
}

// --- üî¥ Streaming Characters Functionality (WebsimSocket) ---
const STREAMING_CHARACTER_COLLECTION = 'blake_reaction_characters_v2'; // v2 para nova estrutura

// ‚ú® Save current character to the "streaming" list (WebsimSocket)
saveToStreamBtn.addEventListener('click', async () => {
  if (!currentCharacter.name || !currentCharacter.personality) {
    updateStatus("Por favor, defina um nome e personalidade para o personagem antes de salvar.", true);
    return;
  }

  try {
    updateStatus(`Salvando ${currentCharacter.name} na transmiss√£o...`);
    // Verifica se j√° existe um personagem com o mesmo nome pelo mesmo usu√°rio
    const existingCharacters = room.collection(STREAMING_CHARACTER_COLLECTION)
                                .filter({ username: (await window.websim.getUser())?.username, characterName: currentCharacter.name })
                                .getList();

    if (existingCharacters.length > 0) {
        // Atualiza o personagem existente
        const charToUpdate = existingCharacters[0];
        await room.collection(STREAMING_CHARACTER_COLLECTION).update(charToUpdate.id, {
            characterPersonality: currentCharacter.personality,
            customImages: currentCharacter.customImages,
            description: currentCharacter.description || `Personagem ${currentCharacter.name}`,
        });
        updateStatus(`${currentCharacter.name} atualizado na transmiss√£o!`);
    } else {
        // Cria um novo personagem
        await room.collection(STREAMING_CHARACTER_COLLECTION).create({
            characterName: currentCharacter.name,
            characterPersonality: currentCharacter.personality,
            customImages: currentCharacter.customImages,
            description: currentCharacter.description || `Personagem ${currentCharacter.name}`,
            // username √© adicionado automaticamente pelo WebsimSocket
        });
        updateStatus(`${currentCharacter.name} salvo na transmiss√£o! Outros poder√£o v√™-lo.`);
    }
  } catch (error) {
    console.error("Erro ao salvar personagem na transmiss√£o:", error);
    updateStatus("Erro ao salvar personagem. Tente novamente.", true);
  }
});

// ‚ú® Load characters from "streaming" list (WebsimSocket)
async function loadStreamingCharacters() {
  if (streamingSubscription) {
    streamingSubscription(); // Cancela inscri√ß√£o anterior
  }
  
  streamingList.innerHTML = '<p class="loading-message">Carregando personagens da transmiss√£o...</p>';

  streamingSubscription = room.collection(STREAMING_CHARACTER_COLLECTION).subscribe(async (characters) => {
    streamingCharacters = characters.sort((a, b) => new Date(b.created_at) - new Date(a.created_at)); // Mais recentes primeiro
    renderStreamingCharacters();
  });
}

// ‚ú® Render streaming characters in the UI - Renderiza personagens em streaming na UI
async function renderStreamingCharacters() {
  if (!streamingList) return;
  streamingList.innerHTML = ''; // Limpa a lista

  const currentUser = await window.websim.getUser();
  const currentUsername = currentUser?.username;

  if (streamingCharacters.length === 0) {
    streamingList.innerHTML = '<p class="no-chatters-message">Nenhum personagem na transmiss√£o ainda. Salve o seu!</p>';
    return;
  }

  streamingCharacters.forEach(charData => {
    const charElement = document.createElement('div');
    charElement.classList.add('streaming-character');
    
    const isOwnCharacter = charData.username === currentUsername;
    if (isOwnCharacter) {
        charElement.classList.add('your-character');
    }

    // Imagem de preview: usa a imagem 'normal' se dispon√≠vel, sen√£o um avatar padr√£o
    const previewImageSrc = charData.customImages?.normal || `https://ui-avatars.com/api/?name=${encodeURIComponent(charData.characterName)}&background=random&color=fff&size=50`;

    charElement.innerHTML = `
      <img src="${previewImageSrc}" alt="${charData.characterName}" class="invited-chatter-avatar">
      <div class="character-info">
        <h4>${charData.characterName} ${isOwnCharacter ? '(Seu Personagem)' : ''}</h4>
        <p>${charData.characterPersonality.substring(0, 100)}${charData.characterPersonality.length > 100 ? '...' : ''}</p>
        <p class="creator">Criado por: @${charData.username}</p>
      </div>
      <div class="character-actions">
        <button class="load-streamed-char-btn" data-id="${charData.id}">Usar Este</button>
        ${isOwnCharacter ? `<button class="delete-streamed-char-btn" data-id="${charData.id}">Excluir</button>` : ''}
      </div>
    `;
    streamingList.appendChild(charElement);
  });

  // Add event listeners for new buttons
  document.querySelectorAll('.load-streamed-char-btn').forEach(button => {
    button.addEventListener('click', handleLoadStreamedCharacter);
  });
  document.querySelectorAll('.delete-streamed-char-btn').forEach(button => {
    button.addEventListener('click', handleDeleteStreamedCharacter);
  });
}

// ‚ú® Handle loading a streamed character - Lida com o carregamento de um personagem da transmiss√£o
async function handleLoadStreamedCharacter(event) {
    const charId = event.target.dataset.id;
    const charToLoad = streamingCharacters.find(c => c.id === charId);

    if (charToLoad) {
        currentCharacter.name = charToLoad.characterName;
        currentCharacter.personality = charToLoad.characterPersonality;
        currentCharacter.customImages = charToLoad.customImages || {};
        currentCharacter.description = charToLoad.description || '';
        
        saveCurrentCharacter(); // Salva localmente como o personagem ativo
        applyCharacterToUI();
        blakeMoods = getCharacterMoods(); // Recalcula os humores com as novas imagens
        
        updateStatus(`Personagem "${currentCharacter.name}" carregado da transmiss√£o!`);
        // Opcional: fechar o painel de streaming
        // streamingPanel.classList.add('hidden');
        // currentlyStreamingBtn.textContent = 'Em Transmiss√£o';
    } else {
        updateStatus("N√£o foi poss√≠vel carregar o personagem selecionado.", true);
    }
}

// ‚ú® Handle deleting a streamed character (only owner) - Lida com a exclus√£o de um personagem da transmiss√£o
async function handleDeleteStreamedCharacter(event) {
    const charId = event.target.dataset.id;
    const charToDelete = streamingCharacters.find(c => c.id === charId);

    if (charToDelete && confirm(`Tem certeza que deseja excluir "${charToDelete.characterName}" da transmiss√£o? Esta a√ß√£o n√£o pode ser desfeita.`)) {
        try {
            await room.collection(STREAMING_CHARACTER_COLLECTION).delete(charId);
            updateStatus(`Personagem "${charToDelete.characterName}" exclu√≠do da transmiss√£o.`);
            // A lista ser√° atualizada automaticamente pelo 'subscribe'
        } catch (error) {
            console.error("Erro ao excluir personagem da transmiss√£o:", error);
            updateStatus("Erro ao excluir personagem. Verifique se voc√™ √© o criador.", true);
        }
    }
}

// --- üòä Mood Boost Functionality ---
function initMoodBoostButtons() {
  treatButton.addEventListener('click', () => applyMoodBoost('treat', 10, 30)); // +10 humor, 30s cooldown
  petButton.addEventListener('click', () => applyMoodBoost('pet', 15, 60));     // +15 humor, 60s cooldown
  complimentButton.addEventListener('click', () => applyMoodBoost('compliment', 20, 90)); // +20 humor, 90s cooldown
  updateBoostCooldowns(); // Atualiza estado inicial dos bot√µes
}

function applyMoodBoost(type, amount, cooldownSeconds) {
  if (boostCooldowns[type] > 0) {
    updateStatus(`${currentCharacter.name} ainda est√° aproveitando o √∫ltimo ${type === 'treat' ? 'agrado' : (type === 'pet' ? 'carinho' : 'elogio')}!`, true);
    return;
  }

  currentMoodValue = Math.min(100, currentMoodValue + amount);
  if (moodMeterFill) moodMeterFill.style.width = `${currentMoodValue}%`;
  if (moodValue) {
    moodValue.textContent = `${currentMoodValue}%`;
    moodValue.style.color = getMoodColor(currentMoodValue);
  }
  
  let reactionText = "";
  switch(type) {
      case 'treat': reactionText = `Nhom! Que del√≠cia! Obrigada pelo agrado, humano! *ronrona satisfeito*`; break;
      case 'pet': reactionText = `Awnnn, que carinho bom! Pode continuar, n√£o pare! *se esfrega pedindo mais*`; break;
      case 'compliment': reactionText = `Oh, voc√™ acha? Que gentileza da sua parte! Voc√™ me deixa sem gra√ßa... *corado e abanando o rabo*`; break;
  }
  
  addChatMessage(currentCharacter.name, reactionText, '#ff66cc', blakeMoods.happy.image);
  if (blakeImage) blakeImage.src = blakeMoods.happy.image;
  if (speechBubble) speechBubble.classList.remove('hidden');
  if (document.getElementById('reaction-text')) document.getElementById('reaction-text').textContent = reactionText;
  speakText(reactionText);

  boostCooldowns[type] = cooldownSeconds;
  updateBoostCooldowns();
  
  const interval = setInterval(() => {
    boostCooldowns[type]--;
    updateBoostCooldowns();
    if (boostCooldowns[type] <= 0) {
      clearInterval(interval);
    }
  }, 1000);
}

function updateBoostCooldowns() {
  Object.keys(boostCooldowns).forEach(type => {
    const button = document.getElementById(`${type}-button`);
    const cooldownSpan = document.getElementById(`${type}-cooldown`);
    if (button && cooldownSpan) {
      if (boostCooldowns[type] > 0) {
        button.disabled = true;
        cooldownSpan.textContent = `(${boostCooldowns[type]}s)`;
      } else {
        button.disabled = false;
        cooldownSpan.textContent = '';
      }
    }
  });
}

// --- ‚öôÔ∏è Custom Chatters Modal Functionality ---
const CUSTOM_CHATTERS_STORAGE_KEY = 'blakeReactionCustomChatters';

function initCustomChattersFeature() {
    loadCustomChatters();
    renderInvitedChattersList();

    addChatterBtn.addEventListener('click', () => customChattersModal.classList.add('active'));
    closeModalBtn.addEventListener('click', () => customChattersModal.classList.remove('active'));

    modalTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            modalTabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById(tab.dataset.tab).classList.add('active');
        });
    });

    chatterImageUpload.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => chatterImagePreview.src = e.target.result;
            reader.readAsDataURL(file);
        }
    });
    
    chatterColorInput.addEventListener('input', (e) => colorPreview.style.backgroundColor = e.target.value);

    chatterForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const name = document.getElementById('chatter-name').value.trim();
        const personality = document.getElementById('chatter-personality').value.trim();
        const color = chatterColorInput.value;
        const imageFile = chatterImageUpload.files[0];

        if (!name || !personality) {
            alert("Nome e personalidade s√£o obrigat√≥rios!");
            return;
        }

        let imageUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=random&color=fff`;
        if (imageFile) {
            try {
                updateStatus("Enviando imagem do participante...");
                imageUrl = await websim.upload(imageFile);
                updateStatus("Imagem do participante enviada!");
            } catch (error) {
                console.error("Erro ao enviar imagem do participante:", error);
                updateStatus("Erro ao enviar imagem do participante. Usando avatar padr√£o.", true);
            }
        }
        
        const newChatter = { id: Date.now().toString(), name, personality, image: imageUrl, color };
        customChatters.push(newChatter);
        saveCustomChatters();
        renderInvitedChattersList();
        addChatterToLiveChat(newChatter); // Adiciona ao chat ao vivo
        
        chatterForm.reset();
        chatterImagePreview.src = 'https://ui-avatars.com/api/?name=Novo+Participante&background=random&color=fff';
        colorPreview.style.backgroundColor = '#ff66cc';
        // Mudar para a aba "Participantes Convidados"
        document.querySelector('.modal-tab[data-tab="invited-tab"]').click();
    });
}

function loadCustomChatters() {
    const saved = localStorage.getItem(CUSTOM_CHATTERS_STORAGE_KEY);
    if (saved) {
        customChatters = JSON.parse(saved);
    }
}

function saveCustomChatters() {
    localStorage.setItem(CUSTOM_CHATTERS_STORAGE_KEY, JSON.stringify(customChatters));
}

function renderInvitedChattersList() {
    invitedChattersList.innerHTML = '';
    if (customChatters.length === 0) {
        invitedChattersList.innerHTML = '<p class="no-chatters-message">Nenhum participante personalizado ainda. Crie um na aba "Criar"!</p>';
        return;
    }

    customChatters.forEach(chatter => {
        const chatterElement = document.createElement('div');
        chatterElement.classList.add('invited-chatter');
        chatterElement.innerHTML = `
            <img src="${chatter.image || `https://ui-avatars.com/api/?name=${encodeURIComponent(chatter.name)}&background=random&color=fff&size=50`}" alt="${chatter.name}" class="invited-chatter-avatar">
            <div class="invited-chatter-info">
                <h4 class="invited-chatter-name">${chatter.name} <span class="invited-chatter-color" style="background-color:${chatter.color};"></span></h4>
                <p class="invited-chatter-personality">${chatter.personality.substring(0,80)}${chatter.personality.length > 80 ? '...' : ''}</p>
            </div>
            <div class="invited-chatter-actions">
                ${!activeChatters.find(ac => ac.id === chatter.id) 
                    ? `<button class="invite-chatter-btn" data-id="${chatter.id}">Convidar</button>`
                    : `<button class="kick-chatter-btn" data-id="${chatter.id}">Expulsar</button>`}
                <button class="remove-chatter-btn" data-id="${chatter.id}">Excluir</button>
            </div>
        `;
        invitedChattersList.appendChild(chatterElement);
    });

    document.querySelectorAll('.invite-chatter-btn').forEach(btn => btn.addEventListener('click', (e) => {
        const chatter = customChatters.find(c => c.id === e.target.dataset.id);
        if (chatter) addChatterToLiveChat(chatter);
    }));
    document.querySelectorAll('.kick-chatter-btn').forEach(btn => btn.addEventListener('click', (e) => {
        const chatter = customChatters.find(c => c.id === e.target.dataset.id);
        if (chatter) kickChatterFromLiveChat(chatter.id);
    }));
    document.querySelectorAll('.remove-chatter-btn').forEach(btn => btn.addEventListener('click', (e) => {
        removeCustomChatter(e.target.dataset.id);
    }));
}

function addChatterToLiveChat(chatter) {
    if (!activeChatters.find(ac => ac.id === chatter.id)) {
        activeChatters.push(chatter);
        viewersCount++;
        updateViewersCount();
        addChatMessage('Sistema', `${chatter.name} entrou no chat!`, '#888');
        renderInvitedChattersList(); // Atualiza bot√µes
    }
}

function kickChatterFromLiveChat(chatterId) {
    const chatterIndex = activeChatters.findIndex(ac => ac.id === chatterId);
    if (chatterIndex > -1) {
        const chatter = activeChatters[chatterIndex];
        activeChatters.splice(chatterIndex, 1);
        viewersCount--;
        updateViewersCount();
        addChatMessage('Sistema', `${chatter.name} saiu do chat.`, '#888');
        renderInvitedChattersList(); // Atualiza bot√µes
    }
}

function removeCustomChatter(chatterId) {
    if (confirm("Tem certeza que quer excluir este participante personalizado?")) {
        kickChatterFromLiveChat(chatterId); // Remove do chat ativo se estiver
        customChatters = customChatters.filter(c => c.id !== chatterId);
        saveCustomChatters();
        renderInvitedChattersList();
    }
}

function updateViewersCount() {
    const viewersCountElement = document.getElementById('viewers-count');
    if (viewersCountElement) {
        viewersCountElement.textContent = viewersCount;
    }
}

// --- ‚öôÔ∏è Options Menu Functionality ---
function initOptionsMenu() {
    optionsBtn.addEventListener('click', () => {
        const isHidden = optionsMenu.classList.toggle('hidden');
        optionsBtn.textContent = isHidden ? 'Op√ß√µes' : 'Fechar Op√ß√µes';
    });

    maxRetriesSlider.addEventListener('input', (e) => {
        options.maxRetries = parseInt(e.target.value);
        maxRetriesValue.textContent = options.maxRetries;
        saveOptions();
    });
    
    responseStrengthSlider.addEventListener('input', (e) => {
        options.responseStrength = parseInt(e.target.value);
        responseStrengthValue.textContent = options.responseStrength;
        saveOptions();
    });

    themeToggle.addEventListener('change', (e) => {
        options.darkMode = e.target.checked;
        setTheme(options.darkMode);
        saveOptions();
    });

    // Aplica valores iniciais
    maxRetriesSlider.value = options.maxRetries;
    maxRetriesValue.textContent = options.maxRetries;
    responseStrengthSlider.value = options.responseStrength;
    responseStrengthValue.textContent = options.responseStrength;
    themeToggle.checked = options.darkMode;
}

function loadOptions() {
    const savedOptions = localStorage.getItem('blakeReactionOptions');
    if (savedOptions) {
        try {
            const parsed = JSON.parse(savedOptions);
            // Merge com defaults para garantir que todas as chaves existam
            options = { ...options, ...parsed };
        } catch (e) {
            console.error("Erro ao carregar op√ß√µes, usando padr√µes.", e);
        }
    }
}

function saveOptions() {
    localStorage.setItem('blakeReactionOptions', JSON.stringify(options));
}

function setTheme(darkMode) {
    document.body.classList.toggle('light-mode', !darkMode);
    // Atualizar cores de status e outros elementos se necess√°rio
    updateStatus(statusMessage.textContent); // Re-aplica status com cor correta
}

// ‚ôªÔ∏è Initialize the app - Inicializa a aplica√ß√£o
function init() {
  loadSavedCharacter();
  
  loadOptions(); // ‚öôÔ∏è Carrega as op√ß√µes salvas
  initOptionsMenu(); // Inicializa o menu de op√ß√µes
  
  // Garante que os pain√©is estejam ocultos inicialmente
  if (customizerPanel) customizerPanel.classList.add('hidden');
  if (optionsMenu) optionsMenu.classList.add('hidden');
  if (streamingPanel) streamingPanel.classList.add('hidden');
  
  // Adiciona event listeners para upload de imagens de humor
  document.querySelectorAll('.mood-image-input').forEach(input => {
    input.addEventListener('change', handleMoodImageUpload);
  });
  
  updateCharacterNameSpans(); // Atualiza os nomes do personagem na UI
  updateViewersCount(); // Atualiza contagem inicial de espectadores
  
  try {
    loadStreamingCharacters(); // Carrega personagens em streaming
  } catch (error) {
    console.error('Erro ao carregar personagens em streaming:', error);
  }
  
  initCustomChattersFeature(); // Inicializa funcionalidade de participantes customizados
  
  blakeImage.src = blakeMoods.normal.image;
  
  updateStatus(`${currentCharacter.name} est√° relaxando... Envie um v√≠deo para ver a rea√ß√£o!`);
  
  reactionText.textContent = blakeMoods.normal.phrases[0];
  
  autoReactToggle.checked = autoReactionEnabled;
  ttsToggle.checked = ttsEnabled;
  
  if (moodValue) {
    moodValue.textContent = `${currentMoodValue}%`;
    moodValue.style.color = getMoodColor(currentMoodValue);
  }
  
  // Define visibilidade do painel de debug do localStorage
  const debugVisible = localStorage.getItem('debugVisible');
  if (debugPanel) { // Checa se debugPanel existe
    if (debugVisible === 'false') {
        debugPanel.style.display = 'none';
        if (debugToggle) debugToggle.textContent = 'Mostrar Debug';
    } else {
        debugPanel.style.display = 'block';
        if (debugToggle) debugToggle.textContent = 'Ocultar Debug';
    }
  }
  
  if (debugToggle) {
    debugToggle.addEventListener('click', toggleDebugPanel);
  }
  
  // Prepara a s√≠ntese de voz
  if (window.speechSynthesis) {
    window.speechSynthesis.onvoiceschanged = () => {
        // üí° Poderia carregar vozes preferidas aqui, se necess√°rio
    };
  }
  
  moodSelect.value = userSelectedMood;
  initMoodBoostButtons(); // Inicializa bot√µes de melhoria de humor
  setTheme(options.darkMode); // Aplica o tema salvo
  
  // üí¨ Gera mensagens iniciais de chat com IA
  setTimeout(async () => {
    try {
      const initialChatters = [
          { name: 'Zangos', personality: 'engra√ßado e um pouco ca√≥tico', color: '#ff5722' },
          { name: 'Connie', personality: 'anal√≠tica e curiosa', color: '#2196f3' },
          { name: 'Beary', personality: 'c√≠nico mas com um bom cora√ß√£o', color: '#8bc34a' },
          { name: 'Starlight', personality: 'm√≠stica e sonhadora', color: '#9c27b0' }
      ];
      
      for (const chatter of initialChatters) {
        const completion = await websim.chat.completions.create({
          messages: [
            {
              role: "system",
              content: `Voc√™ √© um espectador chamado ${chatter.name} (${chatter.personality}) no chat da livestream de ${currentCharacter.name} que acabou de entrar.
                        Gere uma √∫nica mensagem de sauda√ß√£o casual e breve (1 frase) que ${chatter.name} postaria ao entrar no chat.
                        Fa√ßa parecer aut√™ntico para a cultura de streaming com tom apropriado, possivelmente usando emotes.
                        N√£o use hashtags, n√£o se apresente e n√£o assine sua mensagem. Responda em portugu√™s brasileiro.`
            },
            {
              role: "user",
              content: `Gere uma mensagem de sauda√ß√£o para ${chatter.name} entrando na stream de ${currentCharacter.name}.`
            }
          ]
        });
        
        addChatMessage(chatter.name, completion.content.trim(), chatter.color, `https://ui-avatars.com/api/?name=${encodeURIComponent(chatter.name)}&background=random&color=fff&size=24`);
        await new Promise(resolve => setTimeout(resolve, 700 + Math.random() * 500)); // Adiciona um pequeno atraso entre as mensagens
      }
      
      // ü§ñ Mensagem de boas-vindas do personagem principal
      setTimeout(async () => {
        const welcomeCompletion = await websim.chat.completions.create({
          messages: [
            {
              role: "system",
              content: `Voc√™ √© ${currentCharacter.name}, ${currentCharacter.personality}. Voc√™ est√° cumprimentando os espectadores no chat da sua livestream.
                        Gere uma mensagem de boas-vindas casual e breve (1-2 frases) para cumprimentar seus espectadores.
                        Fa√ßa parecer aut√™ntico √† sua personalidade, possivelmente usando emotes ou g√≠rias da internet.
                        N√£o use hashtags, n√£o se apresente e n√£o assine sua mensagem. Responda em portugu√™s brasileiro.`
            },
            {
              role: "user",
              content: `Gere uma mensagem de boas-vindas para ${currentCharacter.name} cumprimentando os espectadores em sua stream.`
            }
          ]
        });
        
        const welcomeMessage = welcomeCompletion.content.trim();
        addChatMessage(currentCharacter.name, welcomeMessage, '#ff66cc', blakeMoods.normal.image);
        
        startIdleChat(); // Inicia o chat ocioso ap√≥s as boas-vindas
      }, 1500);
    } catch (error) {
      console.error('Erro ao gerar mensagens iniciais de chat:', error);
      // ‚ö†Ô∏è Fallback para mensagens est√°ticas se a IA falhar
      addChatMessage('Zangos', `Primeiro! Vamos ver o que ${currentCharacter.name} est√° aprontando hoje.`, '#ff5722');
      addChatMessage('Connie', "Oi pessoal! Pronto para umas rea√ß√µes incr√≠veis! ", '#2196f3');
      addChatMessage('Beary', "Aff, outra stream? T√°, acho que vou assistir...", '#8bc34a');
      addChatMessage('Starlight', "As estrelas se alinham para esta reuni√£o c√≥smica de almas ‚ú®", '#9c27b0');
      
      setTimeout(() => {
        addChatMessage(currentCharacter.name, `E a√≠, chat! Prontos para reagir a algum conte√∫do? Mandem um v√≠deo e vamos come√ßar essa festa~`, '#ff66cc', blakeMoods.normal.image);
        startIdleChat();
      }, 2000);
    }
  }, 1000);
  
  // üí° O bot√£o de rea√ß√£o manual √© oculto por padr√£o, pois as rea√ß√µes autom√°ticas s√£o o foco
  if (reactButton) {
    reactButton.style.display = 'none'; 
  }
  
  // Alterna visibilidade do painel de personaliza√ß√£o
  toggleCustomizer.addEventListener('click', function() {
    const isHidden = customizerPanel.classList.toggle('hidden');
    this.textContent = isHidden ? 'Personalizar Personagem' : 'Ocultar Personalizador';
  });

  // Alterna visibilidade do painel "Em Transmiss√£o"
  currentlyStreamingBtn.addEventListener('click', function() {
    const isHidden = streamingPanel.classList.toggle('hidden');
    this.textContent = isHidden ? 'Em Transmiss√£o' : 'Fechar Transmiss√£o';
    if (!isHidden) { // Se est√° abrindo
        loadStreamingCharacters(); // Recarrega a lista ao abrir
    }
  });
}

// ‚ôªÔ∏è Chama a fun√ß√£o init para iniciar a aplica√ß√£o quando o script for carregado
init();
  </script>
</body>
</html>
