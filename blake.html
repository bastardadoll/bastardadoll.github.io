```html
<!DOCTYPE html>
<html lang="pt-br"> <!-- ‚ôªÔ∏è Definindo o idioma da p√°gina como portugu√™s brasileiro -->
<head>
  <meta charset="UTF-8"> <!-- ‚öôÔ∏è Define a codifica√ß√£o de caracteres para UTF-8, suportando acentos e s√≠mbolos -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- üì± Configura a viewport para responsividade em dispositivos m√≥veis -->
  <title>Tempo de Rea√ß√£o do Blake</title> <!-- üìÑ T√≠tulo que aparece na aba do navegador -->
  <style>
    /* üé® ESTILOS GERAIS */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box; /* Garante que padding e border sejam inclu√≠dos na largura/altura total */
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; /* Fontes padr√£o do sistema */
  background-color: #0a1929; /* Cor de fundo principal (azul escuro/noturno) */
  color: #fff; /* Cor de texto padr√£o (branco) */
}

.container {
  max-width: 1000px; /* Largura m√°xima do conte√∫do */
  margin: 0 auto; /* Centraliza o container */
  padding: 20px; /* Espa√ßamento interno */
}

/* üé® CABE√áALHO */
header {
  display: flex; /* Alinha t√≠tulo e emoji lado a lado */
  justify-content: space-between; /* Coloca t√≠tulo √† esquerda e emoji √† direita */
  align-items: center; /* Centraliza verticalmente */
  margin-bottom: 20px;
  padding-bottom: 10px;
  border-bottom: 3px solid #ff66cc; /* Borda inferior rosa choque */
}

h1 {
  color: #ff66cc; /* Cor do t√≠tulo (rosa choque) */
  font-size: 2.5rem; /* Tamanho do t√≠tulo */
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1); /* Sombra sutil */
}

.rainbow-flag { /* Emoji de bandeira e gato */
  font-size: 2rem;
  animation: bounce 2s infinite; /* üí° Anima√ß√£o simples (definir @keyframes bounce) */
}

/* üé® LAYOUT PRINCIPAL */
.main-content {
  display: flex; /* Se√ß√£o de v√≠deo e rea√ß√£o lado a lado */
  flex-direction: row; /* Dire√ß√£o padr√£o, expl√≠cito aqui */
  gap: 20px; /* Espa√ßo entre as se√ß√µes */
}

.video-section { /* Coluna do v√≠deo */
  flex: 6; /* Ocupa 6 partes do espa√ßo flex√≠vel */
  background: #1a2d3d; /* Fundo azul mais claro */
  border-radius: 10px;
  padding: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); /* Sombra para profundidade */
}

.reaction-section { /* Coluna da rea√ß√£o */
  flex: 4; /* Ocupa 4 partes do espa√ßo flex√≠vel */
  background: #1a2d3d;
  border-radius: 10px;
  padding: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

/* üé® SE√á√ÉO DO V√çDEO */
.video-container {
  display: flex;
  flex-direction: column; /* Input de upload, player e bot√£o empilhados */
  gap: 10px;
}

#video-upload { /* Input de upload escondido (usamos o label) */
  display: none;
}

#upload-label { /* Label estilizado para upload */
  padding: 40px;
  text-align: center;
  border: 3px dashed #aaa; /* Borda tracejada */
  border-radius: 8px;
  cursor: pointer;
  color: #888;
  transition: all 0.3s; /* Anima√ß√£o suave no hover */
}

#upload-label:hover { /* Efeito hover no label de upload */
  background-color: rgba(255, 102, 204, 0.05); /* Fundo rosa claro sutil */
  border-color: #ff66cc;
  color: #ff66cc;
}

#video-player { /* Player de v√≠deo */
  width: 100%;
  border-radius: 8px;
  max-height: 400px; /* Limita a altura do v√≠deo */
  display: none; /* Come√ßa escondido */
}

.input-area { /* √Årea para bot√µes abaixo do v√≠deo/upload */
  display: flex;
  margin-top: 10px;
  justify-content: flex-end; /* Alinha o bot√£o √† direita */
}

#unload-video { /* Bot√£o para remover v√≠deo */
  padding: 8px 15px;
  background: #ff4466; /* Vermelho rosado */
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

/* üé® SE√á√ÉO DE REA√á√ÉO */
.character { /* Cont√™iner da imagem e bal√£o de fala */
  display: flex;
  align-items: flex-start; /* Alinha imagem e bal√£o no topo */
  gap: 20px;
  margin-bottom: 20px;
}

#blake { /* Imagem do personagem */
  width: 150px;
  height: auto;
  transition: transform 0.3s; /* Anima√ß√£o sutil */
  filter: drop-shadow(0 0 5px rgba(255, 102, 204, 0.3)); /* Brilho rosa sutil */
}

.speech-bubble { /* Bal√£o de fala */
  position: relative; /* Para posicionar a "seta" do bal√£o */
  background: #1a2d3d; /* Mesmo fundo das se√ß√µes */
  border: 2px solid #ff66cc; /* Borda rosa */
  border-radius: 15px;
  padding: 15px;
  max-width: 300px;
  min-height: 80px; /* Altura m√≠nima para acomodar texto */
  margin-top: 20px; /* Alinha um pouco abaixo do topo da imagem */
}

.speech-bubble:before { /* "Seta" do bal√£o de fala */
  content: '';
  position: absolute;
  left: -20px; /* Posiciona √† esquerda do bal√£o */
  top: 20px;
  border: 10px solid transparent; /* Cria um tri√¢ngulo transparente */
  border-right-color: #ff66cc; /* Preenche o lado direito com a cor da borda */
}

.speech-bubble p {
  font-size: 1.1rem;
  color: #fff;
}

.hidden { /* Classe utilit√°ria para esconder elementos */
  display: none;
}

.controls { /* Cont√™iner para os controles de rea√ß√£o */
  display: flex;
  flex-direction: column;
  gap: 15px;
}

#react-button { /* Bot√£o principal de rea√ß√£o manual */
  padding: 12px 25px;
  background: #ff66cc; /* Rosa */
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 1.1rem;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s;
}

#react-button:disabled { /* Estilo quando desabilitado */
  background: #cccccc;
  cursor: not-allowed;
}

#react-button:not(:disabled):hover { /* Efeito hover quando habilitado */
  background: #ff33bb; /* Rosa mais escuro */
  transform: scale(1.05); /* Leve aumento */
}

.reaction-indicator { /* √Årea do medidor de humor */
  margin-top: 10px;
}

.mood-meter { /* Cont√™iner do medidor (label + barra) */
  display: flex;
  align-items: center;
  gap: 10px;
}

.mood-label {
  font-weight: bold;
  color: #ccc; /* Cor mais clara para o label */
}

#mood-bar { /* Barra de humor */
  height: 20px;
  width: 100%;
  /* Gradiente de cores representando o humor (ruim -> bom) */
  background: linear-gradient(to right, #ff0000, #ffff00, #00ff00, #0000ff, #ff00ff);
  border-radius: 10px;
  position: relative; /* Para posicionar o preenchimento */
  overflow: hidden; /* Para esconder o preenchimento que excede */
}

#mood-meter-fill { /* Preenchimento da barra (representa o valor atual) */
  position: absolute;
  height: 100%;
  width: 0%; /* Come√ßa vazio, atualizado via JS */
  background-color: rgba(255, 255, 255, 0.3); /* Branco semi-transparente */
  transition: width 0.5s ease; /* Anima√ß√£o suave da largura */
}

/* #mood-bar:after { display: none; } üí° Regra vazia, pode ser removida */

.mood-value { /* Texto com o valor percentual do humor */
  margin-top: 5px;
  text-align: right;
  font-size: 1.2rem;
  font-weight: bold;
}

.mood-selection { /* Sele√ß√£o manual de humor */
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
}

#mood-select { /* Dropdown de sele√ß√£o de humor */
  padding: 5px;
  border-radius: 4px;
  background: #1a2d3d;
  color: white;
  border: 1px solid #ff66cc;
}

.text-to-speech-toggle { /* Toggle para ativar/desativar TTS */
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
}

.status-area { /* √Årea para exibir mensagens de status */
  margin-top: 20px;
  text-align: center;
  padding: 10px;
  background: rgba(255, 102, 204, 0.1); /* Fundo rosa bem sutil */
  border-radius: 8px;
  color: #fff;
}

#status-message {
  font-style: italic;
  color: #ccc;
}

.auto-reaction-toggle { /* Toggle para rea√ß√µes autom√°ticas */
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
}

/* Estilos para o Switch (Toggle) */
.toggle-switch {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 24px;
}

.toggle-switch input { /* Esconde o checkbox padr√£o */
  opacity: 0;
  width: 0;
  height: 0;
}

.slider { /* Parte deslizante visual do toggle */
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc; /* Cor quando desligado */
  transition: .4s; /* Anima√ß√£o */
  border-radius: 24px; /* Totalmente arredondado */
}

.slider:before { /* Bolinha do toggle */
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
  border-radius: 50%; /* C√≠rculo perfeito */
}

input:checked + .slider { /* Cor quando ligado */
  background-color: #ff66cc;
}

input:checked + .slider:before { /* Move a bolinha para a direita quando ligado */
  transform: translateX(26px);
}

/* üé® SE√á√ÉO DE CHAT AO VIVO */
.chat-section {
  background: #1a2d3d;
  border-radius: 10px;
  padding: 15px;
  margin-top: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  height: 300px; /* Altura fixa para o chat */
  display: flex;
  flex-direction: column; /* Organiza header, mensagens e input verticalmente */
  width: 100%; /* Ocupa toda a largura do container pai */
}

.chat-header { /* Cabe√ßalho do chat */
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  padding-bottom: 5px;
  border-bottom: 2px solid #ff66cc;
}

.chat-header h3 {
  color: #ff66cc;
  margin: 0;
}

.chat-header-controls { /* Controles no cabe√ßalho do chat */
  display: flex;
  gap: 10px;
  align-items: center;
}

.add-chatter-btn { /* Bot√£o "Adicionar Participante" */
  background: #ff66cc;
  color: white;
  border: none;
  border-radius: 5px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 0.8rem;
  transition: all 0.3s;
}

.add-chatter-btn:hover {
  background: #ff33bb;
}

.chat-messages { /* √Årea onde as mensagens aparecem */
  flex-grow: 1; /* Ocupa o espa√ßo vertical restante */
  overflow-y: auto; /* Rolagem vertical */
  background: rgba(0, 0, 0, 0.2); /* Fundo escuro semi-transparente */
  border-radius: 8px;
  padding: 10px;
  margin-bottom: 10px;
  display: flex;
  flex-direction: column;
  gap: 5px; /* Espa√ßo entre mensagens */
}

.chat-message { /* Uma √∫nica mensagem no chat */
  display: flex;
  align-items: flex-start; /* Alinha avatar e texto no topo */
  margin-bottom: 5px;
}

.chat-username { /* Nome do usu√°rio no chat */
  font-weight: bold;
  margin-right: 5px;
}

.chat-avatar { /* Avatar do usu√°rio no chat */
  width: 24px;
  height: 24px;
  border-radius: 50%;
  margin-right: 8px;
}

.chat-text { /* Texto da mensagem */
  word-break: break-word; /* Quebra palavras longas */
}

.chat-input-area { /* √Årea de input e bot√£o de enviar */
  display: flex;
  gap: 5px;
}

#chat-input { /* Campo de texto do chat */
  flex-grow: 1;
  padding: 8px;
  border-radius: 4px;
  border: 1px solid #444;
  background: rgba(0, 0, 0, 0.2);
  color: white;
}

#send-chat { /* Bot√£o enviar do chat */
  padding: 8px 15px;
  background: #ff66cc;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* Cores espec√≠ficas para nomes de usu√°rio (opcional) */
.message-zangos .chat-username { color: #ff5722; } /* Laranja */
.message-connie .chat-username { color: #2196f3; } /* Azul */
.message-beary .chat-username { color: #8bc34a; } /* Verde */
.message-starlight .chat-username { color: #9c27b0; } /* Roxo */
.message-user .chat-username { color: #ff66cc; } /* Rosa (usu√°rio principal) */

/* üêû PAINEL DE DEBUG */
.debug-panel {
  background: #333; /* Fundo cinza escuro */
  color: #0f0; /* Texto verde (estilo terminal) */
  padding: 5px 10px;
  font-size: 0.9rem;
  margin-bottom: 10px;
  position: relative; /* Para posicionar o bot√£o toggle */
  white-space: nowrap; /* Impede quebra de linha */
  overflow: hidden; /* Esconde texto que transborda */
  text-overflow: ellipsis; /* Adiciona "..." */
}

.debug-toggle { /* Bot√£o para mostrar/ocultar debug */
  position: absolute;
  right: 10px;
  top: 5px;
  background: #555;
  color: #fff;
  border: none;
  border-radius: 3px;
  padding: 2px 6px;
  font-size: 0.8rem;
  cursor: pointer;
}

/* üé® PERSONALIZADOR DE PERSONAGEM */
.character-customizer {
  background: #1a2d3d;
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

#toggle-customizer { /* Bot√£o para mostrar/ocultar personalizador */
  background: #ff66cc;
  color: white;
  border: none;
  border-radius: 5px;
  padding: 8px 15px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s;
}

#toggle-customizer:hover {
  background: #ff33bb;
}

#customizer-panel { /* Painel que cont√©m as op√ß√µes de personaliza√ß√£o */
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #444; /* Linha separadora */
}

.customizer-section { /* Se√ß√£o dentro do personalizador (ex: Configura√ß√µes, Imagens) */
  margin-bottom: 20px;
}

.customizer-section h3 {
  color: #ff66cc;
  margin-bottom: 10px;
}

.customizer-field { /* Um campo de formul√°rio (label + input/textarea) */
  display: flex;
  align-items: center; /* Alinha label e input verticalmente */
  margin-bottom: 10px;
}

.customizer-field label {
  width: 120px; /* Largura fixa para o label */
  color: #ccc;
}

.customizer-field input, .customizer-field textarea {
  flex: 1; /* Ocupa o espa√ßo restante */
  padding: 8px;
  background: rgba(0, 0, 0, 0.2);
  border: 1px solid #444;
  border-radius: 4px;
  color: white;
}

.customizer-field textarea {
  height: 60px;
  resize: vertical; /* Permite redimensionamento vertical */
}

.customizer-images { /* Cont√™iner para as imagens de humor */
  display: flex;
  gap: 10px;
  flex-wrap: wrap; /* Quebra para a pr√≥xima linha se n√£o couber */
  justify-content: space-between; /* Distribui espa√ßo */
}

.mood-image-selector { /* Bloco para selecionar imagem de um humor espec√≠fico */
  width: 120px; /* Largura fixa */
  text-align: center;
  margin-bottom: 15px;
  background: rgba(0, 0, 0, 0.2);
  padding: 10px;
  border-radius: 5px;
}

.mood-image-selector p { /* Nome do humor (Normal, Feliz, etc.) */
  margin-bottom: 5px;
  color: #ccc;
}

.mood-image-selector img { /* Preview da imagem do humor */
  width: 80px;
  height: 80px;
  object-fit: contain; /* Garante que a imagem caiba sem distorcer */
  margin-bottom: 5px;
}

.mood-image-input { /* Input de upload de imagem (escondido) */
  display: none;
}

.mood-image-label { /* Label estilizado para o input de upload */
  display: inline-block;
  padding: 5px 10px;
  background: #ff66cc;
  color: white;
  border-radius: 3px;
  cursor: pointer;
  font-size: 0.8rem;
}

.customizer-buttons { /* Bot√µes de Salvar e Resetar no personalizador */
  display: flex;
  gap: 10px;
  justify-content: flex-end; /* Alinha √† direita */
}

.customizer-buttons button {
  padding: 8px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

#save-character { /* Bot√£o Salvar Personagem */
  background: #4CAF50; /* Verde */
  color: white;
}

#reset-character { /* Bot√£o Restaurar Padr√£o */
  background: #f44336; /* Vermelho */
  color: white;
}

/* üî¥ PAINEL "EM TRANSMISS√ÉO" (STREAMING) */
.streaming-panel {
  background: #1a2d3d;
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

#currently-streaming-btn { /* Bot√£o para mostrar/ocultar painel de streaming */
  background: #ff66cc;
  color: white;
  border: none;
  border-radius: 5px;
  padding: 8px 15px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s;
  margin-right: 10px; /* Espa√ßo para o pr√≥ximo bot√£o */
}

#currently-streaming-btn:hover {
  background: #ff33bb;
}

#streaming-panel { /* Painel que cont√©m a lista de personagens em streaming */
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #444;
}

.streaming-characters-container { /* Cont√™iner da lista com scroll */
  max-height: 400px;
  overflow-y: auto;
  margin-top: 15px;
}

.streaming-header { /* Cabe√ßalho da lista de streaming */
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.streaming-header h3 {
  color: #ff66cc;
  margin: 0;
}

.streaming-character { /* Um personagem na lista de streaming */
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.your-character { /* Estilo especial para o personagem do pr√≥prio usu√°rio */
  background: rgba(255, 102, 204, 0.15);
  border: 1px solid rgba(255, 102, 204, 0.3);
}

.character-info { /* Informa√ß√µes do personagem (nome, personalidade) */
  flex: 1; /* Ocupa espa√ßo dispon√≠vel */
}

.character-info h4 {
  margin: 0 0 5px 0;
  color: #ff66cc;
}

.character-info p {
  margin: 0 0 5px 0;
  font-size: 0.9rem;
  color: #ddd;
}

.character-info .creator { /* Nome do criador */
  font-size: 0.8rem;
}

/* üòä SE√á√ÉO DE MELHORIA DE HUMOR (MOOD BOOST) */
.mood-boost-section {
  margin-top: 15px;
  background: rgba(255, 102, 204, 0.1); /* Fundo rosa bem sutil */
  border-radius: 8px;
  padding: 10px;
}

.mood-boost-section h3 {
  color: #ff66cc;
  margin-bottom: 10px;
  font-size: 1.1rem;
  text-align: center;
}

.mood-boost-buttons { /* Cont√™iner dos bot√µes de boost */
  display: flex;
  justify-content: space-between; /* Distribui espa√ßo entre bot√µes */
  gap: 8px;
}

.mood-boost-button { /* Bot√µes individuais de boost */
  flex: 1; /* Ocupam espa√ßo igualmente */
  padding: 10px;
  background: linear-gradient(to bottom, #ff66cc, #ff3399); /* Gradiente rosa */
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  transition: all 0.2s ease;
  position: relative; /* Para o timer */
  overflow: hidden;
}

.mood-boost-button:hover { /* Efeito hover */
  transform: translateY(-2px); /* Levanta um pouco */
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  background: linear-gradient(to bottom, #ff3399, #ff0066); /* Gradiente mais escuro */
}

.mood-boost-button:active { /* Efeito ao clicar */
  transform: translateY(1px); /* Afunda um pouco */
  box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.mood-boost-button:disabled { /* Estilo quando em cooldown */
  background: linear-gradient(to bottom, #ffb6db, #ffcce6); /* Rosa p√°lido */
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.cooldown-timer { /* Timer de cooldown no bot√£o */
  font-size: 0.8rem;
  font-weight: normal;
  opacity: 0.8;
  margin-left: 5px;
}

/* üö´ BOT√ÉO EXPULSAR PARTICIPANTE (KICK) */
.kick-chatter-btn {
  padding: 5px 10px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
  background: #ff9800; /* Laranja */
  color: white;
}

.kick-chatter-btn:hover {
  background: #e68300;
}

/* üë§ MODAL DE PARTICIPANTES PERSONALIZADOS */
.custom-chatters-modal {
  position: fixed; /* Ocupa a tela inteira */
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7); /* Fundo escuro semi-transparente */
  display: flex;
  justify-content: center; /* Centraliza horizontalmente */
  align-items: center; /* Centraliza verticalmente */
  z-index: 1000; /* Acima de outros elementos */
  opacity: 0; /* Come√ßa invis√≠vel */
  visibility: hidden; /* Come√ßa n√£o vis√≠vel */
  transition: opacity 0.3s, visibility 0.3s; /* Anima√ß√£o de fade */
}

.custom-chatters-modal.active { /* Estilo quando o modal est√° ativo */
  opacity: 1;
  visibility: visible;
}

.modal-content { /* Conte√∫do interno do modal */
  background: #1a2d3d;
  width: 90%;
  max-width: 600px; /* Largura m√°xima */
  border-radius: 10px;
  padding: 20px;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
  max-height: 90vh; /* Altura m√°xima com rolagem */
  overflow-y: auto;
}

.modal-header { /* Cabe√ßalho do modal */
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 2px solid #ff66cc;
}

.modal-header h3 {
  color: #ff66cc;
  margin: 0;
}

.close-modal { /* Bot√£o 'X' para fechar */
  background: none;
  border: none;
  color: #fff;
  font-size: 1.5rem;
  cursor: pointer;
}

.modal-tabs { /* Abas dentro do modal (Criar / Convidados) */
  display: flex;
  border-bottom: 1px solid #444;
  margin-bottom: 20px;
}

.modal-tab { /* Bot√£o de aba individual */
  padding: 10px 15px;
  background: transparent;
  border: none;
  color: #ccc; /* Cor inativa */
  cursor: pointer;
  transition: all 0.3s;
}

.modal-tab.active { /* Estilo da aba ativa */
  color: #ff66cc;
  border-bottom: 2px solid #ff66cc;
}

.tab-content { /* Conte√∫do de uma aba */
  display: none; /* Escondido por padr√£o */
}

.tab-content.active { /* Conte√∫do da aba ativa */
  display: block;
}

.custom-chatter-form { /* Formul√°rio para criar participante */
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.form-group { /* Grupo de label + input no formul√°rio */
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.form-group label {
  color: #ddd;
  font-size: 0.9rem;
}

.form-group input, .form-group textarea {
  background: rgba(0, 0, 0, 0.2);
  border: 1px solid #444;
  border-radius: 4px;
  padding: 8px;
  color: white;
}

.form-group textarea {
  min-height: 80px;
  resize: vertical;
}

.chatter-image-container { /* Container para preview e bot√£o de upload da imagem */
  display: flex;
  align-items: center;
  gap: 15px;
}

.chatter-image-preview { /* Preview da imagem do participante */
  width: 64px;
  height: 64px;
  border-radius: 50%;
  object-fit: cover;
  background-color: #333;
  border: 2px solid #555;
}

.chatter-image-upload { /* Input de upload (escondido) */
  display: none;
}

.chatter-image-label { /* Label estilizado para upload de imagem */
  padding: 8px 12px;
  background: #333;
  color: white;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  border: 1px solid #555;
}

.color-preview { /* Preview da cor selecionada para o nome */
  width: 24px;
  height: 24px;
  border-radius: 4px;
  display: inline-block;
  margin-left: 10px;
  border: 1px solid #555;
}

.form-actions { /* √Årea dos bot√µes de a√ß√£o do formul√°rio */
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
}

.form-actions button {
  padding: 8px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

.save-chatter-btn { /* Bot√£o Salvar/Convidar participante */
  background: #4CAF50; /* Verde */
  color: white;
}

.invited-chatters-list { /* Lista de participantes convidados */
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.invited-chatter { /* Um participante na lista de convidados */
  background: rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  padding: 15px;
  display: flex;
  align-items: center;
  gap: 15px;
}

.invited-chatter-avatar { /* Avatar na lista de convidados */
  width: 50px;
  height: 50px;
  border-radius: 50%;
  object-fit: cover;
}

.invited-chatter-info { /* Informa√ß√µes do participante convidado */
  flex: 1;
}

.invited-chatter-name {
  font-weight: bold;
  color: white;
  margin: 0 0 5px 0;
}

.invited-chatter-personality {
  font-size: 0.9rem;
  color: #ccc;
  margin: 0;
}

.invited-chatter-color { /* Bolinha de cor do nome */
  width: 18px;
  height: 18px;
  border-radius: 50%;
  margin-left: 5px;
  display: inline-block;
}

.invited-chatter-actions { /* Bot√µes de a√ß√£o para participantes convidados */
  display: flex;
  gap: 5px;
}

.invite-chatter-btn, .remove-chatter-btn, .kick-chatter-btn { /* Estilo base para bot√µes da lista */
  padding: 5px 10px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
}

.invite-chatter-btn { /* Bot√£o Convidar */
  background: #4CAF50; /* Verde */
  color: white;
}

.remove-chatter-btn { /* Bot√£o Excluir (da lista de customizados) */
  background: #f44336; /* Vermelho */
  color: white;
}

.no-chatters-message { /* Mensagem quando n√£o h√° participantes */
  text-align: center;
  color: #888;
  padding: 20px 0;
}

/* ‚öôÔ∏è PAINEL DE OP√á√ïES */
.options-panel {
  background: #1a2d3d;
  border-radius: 10px;
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

#options-btn { /* Bot√£o para mostrar/ocultar op√ß√µes */
  background: #ff66cc;
  color: white;
  border: none;
  border-radius: 5px;
  padding: 8px 15px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.3s;
  margin-right: 10px;
}

#options-btn:hover {
  background: #ff33bb;
}

#options-menu { /* Menu de op√ß√µes (inicialmente oculto) */
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #444;
}

.option-group { /* Grupo de op√ß√µes (ex: Configura√ß√µes do Reator, Apar√™ncia) */
  margin-bottom: 15px;
}

.option-group h3 {
  color: #ff66cc;
  margin-bottom: 10px;
  font-size: 1.1rem;
}

.option-item { /* Uma √∫nica op√ß√£o (label + controle) */
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.option-label {
  flex: 3; /* Ocupa mais espa√ßo */
  color: #ddd;
}

.option-control { /* Controle da op√ß√£o (slider, toggle) */
  flex: 2;
  display: flex;
  justify-content: flex-end;
  align-items: center;
}

.option-control input[type="range"] { /* Slider */
  width: 100%;
}

.range-value { /* Valor exibido ao lado do slider */
  width: 30px;
  text-align: right;
  margin-left: 10px;
  color: #ddd;
}

/* ‚òÄÔ∏è MODO CLARO (LIGHT MODE) */
body.light-mode {
  background-color: #f5f5f5; /* Fundo branco/cinza claro */
  color: #333; /* Texto escuro */
}

/* Adapta cores de fundo e sombra das se√ß√µes principais */
body.light-mode .video-section, 
body.light-mode .reaction-section, 
body.light-mode .chat-section,
body.light-mode .character-customizer,
body.light-mode .streaming-panel,
body.light-mode .customizer-panel,
body.light-mode .options-panel,
body.light-mode .streaming-character,
body.light-mode .modal-content,
body.light-mode .chat-messages {
  background: #ffffff; /* Fundo branco */
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* Sombra mais sutil */
}

/* Adapta bal√£o de fala e texto */
body.light-mode .speech-bubble {
  background: #ffffff;
  border: 2px solid #ff66cc;
}
body.light-mode .speech-bubble p,
body.light-mode .chat-text {
  color: #333; /* Texto escuro */
}

/* Adapta inputs e textareas */
body.light-mode #chat-input,
body.light-mode .customizer-field input, 
body.light-mode .customizer-field textarea,
body.light-mode .form-group input, 
body.light-mode .form-group textarea {
  background: rgba(0, 0, 0, 0.05); /* Fundo cinza muito claro */
  color: #333;
  border: 1px solid #ddd;
}

/* Adapta fundos de elementos menores */
body.light-mode .invited-chatter,
body.light-mode .mood-image-selector,
body.light-mode .chat-messages {
  background: rgba(0, 0, 0, 0.05);
}
  </style>
</head>
<body>
  <!-- ‚ôªÔ∏è Cont√™iner principal de toda a aplica√ß√£o -->
  <div class="container">
    
    <!-- üêû Painel de Debug: Exibe informa√ß√µes para depura√ß√£o -->
    <div id="debug-panel" class="debug-panel hidden"> <!-- Come√ßa escondido -->
      Informa√ß√µes de Debug: Aguardando an√°lise do v√≠deo...
      <button id="debug-toggle" class="debug-toggle">Mostrar Debug</button>
    </div>

    <!-- üó£Ô∏è Cabe√ßalho da p√°gina -->
    <header>
      <h1 id="page-title">Tempo de Rea√ß√£o do Blake</h1> <!-- T√≠tulo principal da p√°gina -->
      <div class="rainbow-flag">üè≥Ô∏è‚Äçüåà üê±</div> <!-- üè≥Ô∏è‚Äçüåà Emoji decorativo -->
    </header>
    
    <!-- ü§ñüõ†Ô∏è Se√ß√£o de Personaliza√ß√£o do Personagem e Op√ß√µes -->
    <div class="character-customizer">
      <!-- üîò Bot√µes de acesso r√°pido para op√ß√µes e pain√©is -->
      <div class="customizer-buttons">
        <button id="options-btn">Op√ß√µes</button>
        <button id="currently-streaming-btn">Em Transmiss√£o</button>
        <button id="toggle-customizer">Personalizar Personagem</button>
      </div>
      
      <!-- ‚öôÔ∏è Painel de Op√ß√µes (inicialmente oculto) -->
      <div id="options-menu" class="options-panel hidden">
        <div class="option-group">
          <h3>Configura√ß√µes do Reator</h3> <!-- Configura√ß√µes do "Reator" (Blake) -->
          <div class="option-item">
            <div class="option-label">M√°ximo de Tentativas (Erro IA):</div>
            <div class="option-control">
              <input type="range" id="max-retries" min="1" max="10" value="3"> <!-- üì• Slider para tentativas m√°ximas -->
              <span class="range-value" id="max-retries-value">3</span>
            </div>
          </div>
          <div class="option-item">
            <div class="option-label">For√ßa/Sarcasmo da Resposta:</div>
            <div class="option-control">
              <input type="range" id="response-strength" min="1" max="10" value="7"> <!-- üì• Slider para for√ßa da resposta -->
              <span class="range-value" id="response-strength-value">7</span>
            </div>
          </div>
        </div>
        
        <div class="option-group">
          <h3>Apar√™ncia</h3> <!-- Configura√ß√µes de Apar√™ncia -->
          <div class="option-item">
            <div class="option-label">Modo Escuro/Claro:</div>
            <div class="option-control">
              <label class="toggle-switch">
                <input type="checkbox" id="theme-toggle" checked> <!-- üì• Toggle para modo escuro/claro -->
                <span class="slider"></span>
              </label>
            </div>
          </div>
        </div>
      </div>
      
      <!-- üî¥ Painel de Personagens em Streaming (inicialmente oculto) -->
      <div id="streaming-panel" class="hidden">
        <div class="streaming-header">
          <h3>Personagens em Transmiss√£o</h3>
          <button id="save-to-stream">Salvar Personagem Atual</button> <!-- üì• Salvar personagem atual na lista online -->
        </div>
        <div class="streaming-characters-container">
          <div id="streaming-characters">
            <!-- üîç Personagens em streaming ser√£o listados aqui -->
            <p class="loading-message">Carregando personagens...</p>
          </div>
        </div>
      </div>
      
      <!-- üé® Painel de Personaliza√ß√£o do Personagem (inicialmente oculto) -->
      <div id="customizer-panel" class="hidden">
        <div class="customizer-section">
          <h3>Configura√ß√µes do Personagem</h3> <!-- ü§ñ Configura√ß√µes do Personagem -->
          <div class="customizer-field">
            <label for="character-name">Nome:</label>
            <input type="text" id="character-name" placeholder="Blake"> <!-- üì• Nome do personagem -->
          </div>
          <div class="customizer-field">
            <label for="character-personality">Personalidade:</label>
            <textarea id="character-personality" placeholder="Um gato furry gay espirituoso e um pouco pregui√ßoso que ama conte√∫do LGBTQ+"></textarea> <!-- üì• Personalidade -->
          </div>
        </div>
        
        <div class="customizer-section">
          <h3>Imagens do Personagem</h3> <!-- ü§ñ Imagens de Humor do Personagem -->
          <div class="customizer-images">
            <!-- üñºÔ∏è Seletor de imagem para cada humor -->
            <div class="mood-image-selector" data-mood="normal">
              <p>Normal</p>
              <img src="Normal.png" alt="Normal"> <!-- ü§ñ Imagem padr√£o "Normal" -->
              <input type="file" id="normal-image" accept="image/*" class="mood-image-input"> <!-- üì• Upload de nova imagem -->
              <label for="normal-image" class="mood-image-label">Alterar</label>
            </div>
            <div class="mood-image-selector" data-mood="happy">
              <p>Feliz</p>
              <img src="Happy.png" alt="Feliz"> <!-- ü§ñ Imagem "Feliz" -->
              <input type="file" id="happy-image" accept="image/*" class="mood-image-input">
              <label for="happy-image" class="mood-image-label">Alterar</label>
            </div>
            <div class="mood-image-selector" data-mood="sad">
              <p>Triste</p>
              <img src="Reaction Thing that appears when NSFW or smth is shown idk.png" alt="Triste"> <!-- ü§ñ Imagem "Triste" -->
              <input type="file" id="sad-image" accept="image/*" class="mood-image-input">
              <label for="sad-image" class="mood-image-label">Alterar</label>
            </div>
            <div class="mood-image-selector" data-mood="angry">
              <p>Com Raiva</p>
              <img src="Anger.png" alt="Com Raiva"> <!-- ü§ñ Imagem "Com Raiva" -->
              <input type="file" id="angry-image" accept="image/*" class="mood-image-input">
              <label for="angry-image" class="mood-image-label">Alterar</label>
            </div>
            <div class="mood-image-selector" data-mood="shocked">
              <p>Chocado</p>
              <img src="Shocked.png" alt="Chocado"> <!-- ü§ñ Imagem "Chocado" -->
              <input type="file" id="shocked-image" accept="image/*" class="mood-image-input">
              <label for="shocked-image" class="mood-image-label">Alterar</label>
            </div>
             <div class="mood-image-selector" data-mood="traumatized">
              <p>Traumatizado</p>
              <img src="Bleeding/Trauma.png" alt="Traumatizado"> <!-- ü§ñ Imagem "Traumatizado" -->
              <input type="file" id="traumatized-image" accept="image/*" class="mood-image-input">
              <label for="traumatized-image" class="mood-image-label">Alterar</label>
            </div>
            <div class="mood-image-selector" data-mood="praying">
              <p>Rezando</p>
              <img src="Pray.png" alt="Rezando"> <!-- ü§ñ Imagem "Rezando" -->
              <input type="file" id="praying-image" accept="image/*" class="mood-image-input">
              <label for="praying-image" class="mood-image-label">Alterar</label>
            </div>
            <!-- üí° Adicionar mais humores aqui se necess√°rio -->
          </div>
        </div>
        
        <!-- üîò Bot√µes de A√ß√£o do Personalizador -->
        <div class="customizer-buttons">
          <button id="save-character">Salvar Personagem</button> <!-- Salvar altera√ß√µes -->
          <button id="reset-character">Restaurar Padr√£o</button> <!-- Resetar para padr√£o -->
        </div>
      </div>
    </div>
    
    <!-- ‚ôªÔ∏è Conte√∫do Principal: Se√ß√£o de V√≠deo e Se√ß√£o de Rea√ß√£o -->
    <div class="main-content">
      <!-- üé¨ Se√ß√£o para upload e visualiza√ß√£o de v√≠deo -->
      <div class="video-section">
        <div class="video-container">
          <input type="file" id="video-upload" accept="video/*"> <!-- üì• Input para upload de v√≠deo -->
          <label for="video-upload" id="upload-label">Arraste o v√≠deo aqui ou clique para enviar</label>
          <video id="video-player" controls></video> <!-- Player de v√≠deo -->
          <div class="input-area">
            <button id="unload-video" class="hidden">Remover V√≠deo</button> <!-- Descarregar v√≠deo (come√ßa oculto) -->
          </div>
        </div>
      </div>
      
      <!-- ü§ñ Se√ß√£o de Rea√ß√£o do Personagem -->
      <div class="reaction-section">
        <div class="character"> <!-- Cont√™iner do personagem e bal√£o de fala -->
          <img id="blake" src="Normal.png" alt="Blake"> <!-- Imagem do personagem Blake -->
          <div class="speech-bubble hidden" id="speech-bubble"> <!-- Bal√£o de fala (inicialmente oculto) -->
            <p id="reaction-text">Ol√°, sou o Blake! Mostre-me algo interessante!</p> <!-- Texto da rea√ß√£o -->
          </div>
        </div>
        <div class="controls"> <!-- Controles relacionados √† rea√ß√£o -->
          <div class="auto-reaction-toggle">
            <label class="toggle-switch">
              <input type="checkbox" id="auto-react-toggle" checked> <!-- üì• Toggle para rea√ß√µes autom√°ticas (ligado por padr√£o) -->
              <span class="slider"></span>
            </label>
            <span>Rea√ß√µes Autom√°ticas</span>
          </div>
          <div class="mood-selection">
            <label for="mood-select">Definir Humor de <span class="character-name-span">Blake</span>:</label>
            <select id="mood-select"> <!-- üì• Sele√ß√£o manual de humor -->
              <option value="auto">Autom√°tico</option>
              <option value="normal">Normal</option>
              <option value="happy">Feliz</option>
              <option value="sad">Triste</option>
              <option value="angry">Com Raiva</option>
              <option value="shocked">Chocado</option>
              <option value="traumatized">Traumatizado</option>
              <option value="praying">Rezando</option>
            </select>
          </div>
          <div class="text-to-speech-toggle">
            <label class="toggle-switch">
              <input type="checkbox" id="tts-toggle"> <!-- üì• Toggle para Text-to-Speech (TTS) -->
              <span class="slider"></span>
            </label>
            <span>Texto para Fala</span>
          </div>
          <div class="reaction-indicator"> <!-- Indicador de humor -->
            <div class="mood-meter">
              <div class="mood-label">Humor de <span class="character-name-span">Blake</span>:</div>
              <div id="mood-bar"> <!-- Barra de humor visual -->
                <div id="mood-meter-fill"></div>
              </div>
            </div>
            <div id="mood-value" class="mood-value">50%</div> <!-- Valor num√©rico do humor -->
          </div>
          <!-- üòä Se√ß√£o para "melhorar" o humor de Blake -->
          <div class="mood-boost-section">
            <h3>Ajude <span class="character-name-span">Blake</span> a se Sentir Melhor</h3>
            <div class="mood-boost-buttons">
              <button id="treat-button" class="mood-boost-button treat-button">Dar Guloseima <span id="treat-cooldown" class="cooldown-timer"></span></button> <!-- Dar um "agrado" -->
              <button id="pet-button" class="mood-boost-button pet-button">Fazer Carinho em <span class="character-name-span">Blake</span> <span id="pet-cooldown" class="cooldown-timer"></span></button> <!-- Fazer carinho -->
              <button id="compliment-button" class="mood-boost-button compliment-button">Elogiar <span id="compliment-cooldown" class="cooldown-timer"></span></button> <!-- Elogiar -->
            </div>
          </div>
          <!-- üí° Bot√£o de rea√ß√£o manual oculto por padr√£o, rea√ß√µes autom√°ticas s√£o o foco -->
          <button id="react-button" class="hidden">Obter Rea√ß√£o de Blake</button>
        </div>
      </div>
    </div>
    
    <!-- üí¨ Se√ß√£o de Chat ao Vivo -->
    <div class="chat-section">
      <div class="chat-header">
        <h3>Chat ao Vivo</h3>
        <div class="chat-header-controls">
          <button id="add-chatter-btn" class="add-chatter-btn">Adicionar Participante</button> <!-- Adicionar participante customizado -->
          <span>üë• Online: <span id="viewers-count">4</span></span> <!-- Contador de espectadores (inicial) -->
        </div>
      </div>
      <div class="chat-messages" id="chat-messages">
        <!-- üîç Mensagens do chat ser√£o adicionadas aqui dinamicamente -->
      </div>
      <div class="chat-input-area">
        <input type="text" id="chat-input" placeholder="Diga algo..."> <!-- üì• Campo para digitar mensagem -->
        <button id="send-chat">Enviar</button> <!-- Bot√£o para enviar mensagem -->
      </div>
    </div>
    
    <!-- üì¢ √Årea de Status da Aplica√ß√£o -->
    <div class="status-area">
      <p id="status-message">Blake est√° relaxando... Envie um v√≠deo para ver a rea√ß√£o dele!</p>
    </div>
  </div> <!-- Fim do .container principal -->
  
  <!-- üë§ Modal para Adicionar Participantes Customizados ao Chat -->
  <div id="custom-chatters-modal" class="custom-chatters-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Participantes Personalizados</h3>
        <button id="close-modal-btn" class="close-modal">√ó</button> <!-- Bot√£o para fechar o modal -->
      </div>
      
      <!-- Abas do Modal: Criar e Convidados -->
      <div class="modal-tabs">
        <button class="modal-tab active" data-tab="create-tab">Criar</button>
        <button class="modal-tab" data-tab="invited-tab">Participantes Convidados</button>
      </div>
      
      <!-- üìù Aba de Cria√ß√£o de Participante -->
      <div id="create-tab" class="tab-content active">
        <form id="chatter-form" class="custom-chatter-form"> <!-- üì• Formul√°rio para criar participante -->
          <div class="form-group">
            <label for="chatter-name">Nome:</label>
            <input type="text" id="chatter-name" required placeholder="Digite o nome do participante">
          </div>
          
          <div class="form-group">
            <label for="chatter-personality">Personalidade:</label>
            <textarea id="chatter-personality" required placeholder="Descreva a personalidade deste participante"></textarea>
          </div>
          
          <div class="form-group">
            <label for="chatter-image">Foto de Perfil:</label>
            <div class="chatter-image-container">
              <img id="chatter-image-preview" class="chatter-image-preview" src="https://ui-avatars.com/api/?name=Novo+Participante&background=random&color=fff" alt="Pr√©via do Participante"> <!-- Preview da imagem -->
              <input type="file" id="chatter-image-upload" class="chatter-image-upload" accept="image/*"> <!-- üì• Upload da imagem -->
              <label for="chatter-image-upload" class="chatter-image-label">Escolher Imagem</label>
            </div>
          </div>
          
          <div class="form-group">
            <label for="chatter-color">Cor do Nome de Usu√°rio:</label>
            <input type="color" id="chatter-color" value="#ff66cc"> <!-- üì• Seletor de cor para o nome -->
            <span id="color-preview" class="color-preview" style="background-color: #ff66cc"></span> <!-- Preview da cor -->
          </div>
          
          <div class="form-actions">
            <button type="submit" class="save-chatter-btn">Convidar para o Chat ao Vivo</button> <!-- Convidar para o chat -->
          </div>
        </form>
      </div>
      
      <!-- üìú Aba de Participantes Convidados -->
      <div id="invited-tab" class="tab-content">
        <div id="invited-chatters-list" class="invited-chatters-list">
          <!-- üîç Lista de participantes customizados convidados -->
          <p class="no-chatters-message">Nenhum participante personalizado ainda. Crie um na aba "Criar"!</p>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // Blake's Reaction Time - Main JavaScript

// üîç DOM Elements - Sele√ß√£o dos elementos HTML que ser√£o manipulados
// --- Elementos Principais ---
const videoUpload = document.getElementById('video-upload');
const uploadLabel = document.getElementById('upload-label');
const videoPlayer = document.getElementById('video-player');
const unloadVideoButton = document.getElementById('unload-video');
const statusMessage = document.getElementById('status-message'); // üì¢ Mensagem de status da aplica√ß√£o
const pageTitle = document.getElementById('page-title'); // T√≠tulo da p√°gina
const container = document.querySelector('.container'); // Container principal

// --- Elementos do Personagem Reator (Blake) ---
const blakeImage = document.getElementById('blake'); // ü§ñ Imagem do personagem principal
const speechBubble = document.getElementById('speech-bubble'); // üí¨ Bal√£o de fala
const reactionText = document.getElementById('reaction-text'); // üó£Ô∏è Texto dentro do bal√£o de fala
const moodBar = document.getElementById('mood-bar'); // üå°Ô∏è Barra de humor visual
const moodMeterFill = document.getElementById('mood-meter-fill'); // Preenchimento da barra de humor
const moodValue = document.getElementById('mood-value'); // Valor percentual do humor
const moodSelect = document.getElementById('mood-select'); // ‚öôÔ∏è Seletor manual de humor

// --- Controles ---
const reactButton = document.getElementById('react-button'); // Bot√£o de rea√ß√£o manual (oculto por padr√£o)
const autoReactToggle = document.getElementById('auto-react-toggle'); // ‚öôÔ∏è Toggle para rea√ß√µes autom√°ticas
const ttsToggle = document.getElementById('tts-toggle'); // ‚öôÔ∏è Toggle para Text-to-Speech
const treatButton = document.getElementById('treat-button'); // üç¨ Bot√£o dar guloseima
const petButton = document.getElementById('pet-button'); // üëã Bot√£o fazer carinho
const complimentButton = document.getElementById('compliment-button'); // ü•∞ Bot√£o elogiar
const characterNameSpans = document.querySelectorAll('.character-name-span'); // Spans para exibir o nome do personagem

// --- Chat ---
const chatMessages = document.getElementById('chat-messages'); // √Årea de exibi√ß√£o das mensagens do chat
const chatInput = document.getElementById('chat-input'); // üì• Campo de entrada do chat
const sendChatButton = document.getElementById('send-chat'); // Bot√£o para enviar mensagem no chat
const addChatterBtn = document.getElementById('add-chatter-btn'); // Bot√£o no header do chat para abrir modal
const viewersCountElement = document.getElementById('viewers-count'); // Span para contagem de espectadores

// --- Debug ---
const debugPanel = document.getElementById('debug-panel'); // üêû Painel de debug
const debugToggle = document.getElementById('debug-toggle'); // Bot√£o para mostrar/ocultar debug

// --- Personaliza√ß√£o ---
const toggleCustomizer = document.getElementById('toggle-customizer'); // Bot√£o para mostrar/ocultar personalizador
const customizerPanel = document.getElementById('customizer-panel'); // üé® Painel de personaliza√ß√£o
const characterNameInput = document.getElementById('character-name'); // üì• Campo nome do personagem
const characterPersonalityInput = document.getElementById('character-personality'); // üì• Campo personalidade
const saveCharacter = document.getElementById('save-character'); // Bot√£o salvar personagem
const resetCharacter = document.getElementById('reset-character'); // Bot√£o resetar personagem
const moodImageSelectors = document.querySelectorAll('.mood-image-selector'); // Seletores de imagem de humor

// --- Streaming ---
const currentlyStreamingBtn = document.getElementById('currently-streaming-btn');
const streamingPanel = document.getElementById('streaming-panel');
const streamingList = document.getElementById('streaming-characters');
const saveToStreamBtn = document.getElementById('save-to-stream');

// --- Modal de Participantes Customizados ---
const customChattersModal = document.getElementById('custom-chatters-modal');
const closeModalBtn = document.getElementById('close-modal-btn');
const modalTabs = document.querySelectorAll('.modal-tab');
const tabContents = document.querySelectorAll('.tab-content');
const invitedChattersList = document.getElementById('invited-chatters-list');
const chatterForm = document.getElementById('chatter-form');
const chatterImagePreview = document.getElementById('chatter-image-preview');
const chatterImageUpload = document.getElementById('chatter-image-upload');
const chatterColorInput = document.getElementById('chatter-color');
const colorPreview = document.getElementById('color-preview');
const chatterNameInput = document.getElementById('chatter-name');
const chatterPersonalityInput = document.getElementById('chatter-personality');

// --- Menu de Op√ß√µes ---
const optionsBtn = document.getElementById('options-btn');
const optionsMenu = document.getElementById('options-menu');
const maxRetriesSlider = document.getElementById('max-retries');
const maxRetriesValue = document.getElementById('max-retries-value');
const themeToggle = document.getElementById('theme-toggle');
const responseStrengthSlider = document.getElementById('response-strength');
const responseStrengthValue = document.getElementById('response-strength-value');

// --- Vari√°veis de Estado e Configura√ß√£o ---
// ‚öôÔ∏è Options settings - Configura√ß√µes da aplica√ß√£o (carregadas do localStorage)
let options = {
  maxRetries: 3,
  darkMode: true,
  responseStrength: 7 // N√≠vel de "atrevimento/sarcasmo" (1-10)
};

// ü§ñ Custom character variables - Vari√°veis do personagem customiz√°vel (carregadas do localStorage)
let currentCharacter = {
  name: 'Blake',
  personality: 'um gato furry gay espirituoso e um pouco pregui√ßoso que ama conte√∫do LGBTQ+',
  customImages: {}, // Armazena URLs de imagens personalizadas para cada humor
  description: 'Um gato furry gay espirituoso com uma atitude pregui√ßosa, mas sagaz. Blake ama conte√∫do LGBTQ+ e n√£o tem medo de ser dram√°tico.' // üí° Descri√ß√£o adicionada
};

// üî¥ New variable for character database - Vari√°vel para o "banco de dados" de personagens em streaming
let streamingCharacters = []; // Array para armazenar personagens da cole√ß√£o online

// üó£Ô∏è Custom chatters variables - Vari√°veis para participantes customizados do chat
const CUSTOM_CHATTERS_STORAGE_KEY = 'blakeReactionCustomChatters_v1'; // Chave para localStorage
let customChatters = []; // Array de participantes criados pelo usu√°rio
let activeChatters = []; // Array de participantes customizados ATIVOS no chat atual
let viewersCount = 4; // Contagem inicial simulada de espectadores

// ‚è±Ô∏è Mood boost cooldown timers - Timers de recarga para melhoria de humor (em segundos)
let boostCooldowns = {
  treat: 0,
  pet: 0,
  compliment: 0
};

// üåê Initialize room for multiplayer functionality - Inicializa a sala para funcionalidade multiplayer (WebsimSocket)
// üí° Substitua 'YOUR_ROOM_NAME' por um nome √∫nico para sua sala/aplica√ß√£o
const room = new WebsimSocket('blake_reaction_room_v1');
let streamingSubscription = null; // Vari√°vel para guardar a inscri√ß√£o na cole√ß√£o

// üå°Ô∏è Current mood value (0-100) - Valor atual do humor
let currentMoodValue = 50; // Come√ßa em 50%

// üìú Chat message history for idle chat - Hist√≥rico de mensagens do chat para conversas ociosas
let chatMessageHistory = []; // Armazena as √∫ltimas mensagens para dar contexto √† IA
const MAX_CHAT_HISTORY = 20; // Limite de mensagens no hist√≥rico
let lastChatReactionTime = 0; // Hora da √∫ltima mensagem/rea√ß√£o no chat (para controlar frequ√™ncia)
let idleChatInterval = null; // Timer para gerar mensagens ociosas
let ambientChatInterval = null; // Timer para gerar mensagens quando o v√≠deo est√° pausado

// üé¨ Current video state - Estado atual do v√≠deo
let videoLoaded = false;
let videoAnalyzed = false; // üí° Esta vari√°vel n√£o parece estar sendo usada efetivamente
let currentVideoBlob = null; // URL do Blob do v√≠deo carregado

// ‚öôÔ∏è Auto reaction variables - Vari√°veis para rea√ß√£o autom√°tica
let autoReactionEnabled = true; // Ligado por padr√£o
let autoReactionInterval = null; // Timer para rea√ß√µes autom√°ticas ao v√≠deo
let lastReactionTime = 0; // Hora da √∫ltima rea√ß√£o ao V√çDEO
let userSelectedMood = 'auto'; // Humor selecionado pelo usu√°rio (padr√£o: autom√°tico)
let ttsEnabled = false; // Text-to-Speech desabilitado por padr√£o

// üìú New reaction history feature - Nova funcionalidade de hist√≥rico de rea√ß√µes AO V√çDEO
let reactionHistory = [];
const MAX_REACTION_HISTORY_LENGTH = 10; // üí° Limite m√°ximo de hist√≥rico de rea√ß√µes ao v√≠deo
let retryAttempts = 0; // Contador de tentativas de retry para a IA

// --- Fun√ß√µes ---

// üêû Fun√ß√£o para atualizar texto de informa√ß√µes de debug
function updateDebugInfo(message) {
  if (debugPanel) {
    // Mant√©m o prefixo e atualiza a mensagem
    debugPanel.textContent = `Info de Debug: ${message}`;
    // Garante que o bot√£o toggle esteja dentro do painel atualizado
    if (!debugPanel.contains(debugToggle)) {
        debugPanel.appendChild(debugToggle);
    }
  }
}

// üêû Alterna visibilidade do painel de debug
function toggleDebugPanel() {
  if (debugPanel) { // Verifica se o elemento existe
      const isHidden = debugPanel.classList.toggle('hidden');
      debugToggle.textContent = isHidden ? 'Mostrar Debug' : 'Ocultar Debug';
      localStorage.setItem('debugVisible', isHidden ? 'false' : 'true');
  }
}

// üå°Ô∏è Fun√ß√£o para atualizar o medidor de humor visualmente e numericamente
function updateMoodMeter(mood) {
  // Valores de impacto no humor para cada tipo de rea√ß√£o
  const moodImpacts = {
    happy: 15, // üòä Aumenta mais
    normal: 0, // Neutro
    sad: -5,       // üò¢ Penalidade reduzida
    angry: -10,    // üò† Penalidade reduzida
    shocked: -3,   // üò≤ Penalidade bem pequena
    traumatized: -15, // üò® Penalidade significativa reduzida
    praying: -8    // üôè Penalidade moderada reduzida
  };

  // S√≥ atualiza o valor se o humor n√£o estiver sendo for√ßado pelo usu√°rio
  if (userSelectedMood === 'auto') {
    currentMoodValue += moodImpacts[mood] || 0; // Adiciona o impacto (ou 0 se humor desconhecido)
    // Garante que o valor fique entre 0 e 100
    currentMoodValue = Math.max(0, Math.min(100, currentMoodValue));
  }

  // Atualiza a barra de preenchimento e o texto do valor
  if (moodMeterFill) {
    moodMeterFill.style.width = `${currentMoodValue}%`;
  }
  if (moodValue) {
    moodValue.textContent = `${currentMoodValue}%`;
    moodValue.style.color = getMoodColor(currentMoodValue); // Define a cor do texto baseada no valor
  }
}

// üé® Fun√ß√£o para obter a cor correspondente √† porcentagem do humor
function getMoodColor(percentage) {
    // Mapeia intervalos de porcentagem para cores
    if (percentage <= 0) return '#ff0000';
    if (percentage <= 10) return '#ff4500';
    if (percentage <= 20) return '#ffa500';
    if (percentage <= 30) return '#ffd700';
    if (percentage <= 40) return '#ffff00';
    if (percentage <= 50) return '#add8e6'; // Azul claro para neutro/ligeiramente positivo
    if (percentage <= 60) return '#90ee90'; // Verde claro
    if (percentage <= 70) return '#00ff00'; // Verde
    if (percentage <= 80) return '#00ced1'; // Turquesa escuro
    if (percentage <= 90) return '#1e90ff'; // Azul dodger
    return '#ff69b4'; // Rosa choque para muito alto
}


// üìç Calcula a posi√ß√£o "ideal" na barra para cada humor (ajuda na visualiza√ß√£o, mas n√£o usado diretamente para preencher)
function getMoodPosition(mood) {
  switch (mood) {
    case 'happy': return 85;
    case 'normal': return 50;
    case 'sad': return 25;
    case 'angry': return 10;
    case 'shocked': return 65; // Chocado √© mais neutro/positivo em surpresa
    case 'traumatized': return 5;
    case 'praying': return 40; // Rezando pode ser neutro/levemente negativo
    default: return 50;
  }
}

// ü§ñ Retorna o objeto com as imagens e frases para cada humor, usando imagens customizadas se existirem
function getCharacterMoods() {
  // Imagens padr√£o como fallback
  const defaultImages = {
    normal: 'Normal.png',
    happy: 'Happy.png',
    sad: 'Reaction Thing that appears when NSFW or smth is shown idk.png', // üí° Nome longo e descritivo, poderia simplificar
    angry: 'Anger.png',
    shocked: 'Shocked.png',
    traumatized: 'Bleeding/Trauma.png', // üí° Estrutura de pasta
    praying: 'Pray.png'
  };

  // Frases para cada humor
  const phrases = {
    normal: [
        `Pronto pra assistir! Espero que seja bom... *mexe as orelhas*`,
        `Mostre algo legal, t√¥ esperando~ *balan√ßa o rabo impacientemente*`,
        `Hmm, vamos ver... Pregui√ßa de me animar ainda. *boceja*`
    ],
    happy: [
        `OMG, AMEI! Totalmente a minha vibe! *ronrona alto* üòª`,
        `SIIIM! √â pra isso que eu pago internet! *rabo balan√ßando feliz* ‚ú®`,
        `Isso me d√° tanta alegria! Nem aguento! *amassa p√£ozinho* ü•∞`
    ],
    sad: [
        `Ah... que bad. T√¥ sentindo aqui... *orelhas caem* üòø`,
        `Nossa, por que fiquei emotivo? Muito sentimental isso. *miado triste*`,
        `N√£o tava esperando chorar hoje, mas c√° estamos. *enrola o rabo* üò•`
    ],
    angry: [
        `N√ÉO! Quem permitiu isso?! *silvo baixo* üò†`,
        `Absurdo! Totalmente problem√°tico! *pelos eri√ßados*`,
        `A AUD√ÅCIA desse conte√∫do. T√¥ pistola! *rabo chicoteando* üí¢`
    ],
    shocked: [
        `QUE RAIOS eu acabei de ver?! N√ÉO tava preparado! *pelos arrepiados* üôÄ`,
        `Meu queixo caiu! Chocado! *garras cravam no sof√° imagin√°rio*`,
        `GENTE?! Isso √© real?! *orelhas achatadas* üò≤`
    ],
    traumatized: [
        `Eu... preciso de terapia depois disso. *bigodes tremendo* üò®`,
        `Certas coisas n√£o podem ser desvistas. Essa √© uma delas. *se encolhe todo*`,
        `Minha alma saiu do corpo. N√£o t√¥ bem n√£o. *rabo entre as pernas* üòµ`
    ],
    praying: [
        `Deuses gays, por favor, limpem meus olhos e minha alma. *patinhas juntas* üôè`,
        `Rezando por quem fez isso... e por mim que assisti. *miado reverente*`,
        `Sinal divino pra eu ir meditar... ou assistir algo mais leve. *ronronar solene* üßò`
    ]
  };

  // Monta o objeto final, usando imagem customizada ou padr√£o
  const moods = {};
  for (const mood in defaultImages) {
    moods[mood] = {
      image: currentCharacter.customImages[mood] || defaultImages[mood],
      phrases: phrases[mood] || phrases.normal // Usa frases normais como fallback se n√£o encontrar
    };
  }
  return moods;
}

// ü§ñ Define os humores do personagem inicialmente
let blakeMoods = getCharacterMoods();

// üìú Hist√≥rico de rea√ß√µes AO V√çDEO
let reactionHistory = [];
const MAX_HISTORY_LENGTH = 10; // Limite m√°ximo de rea√ß√µes no hist√≥rico

// üé¨ Vari√°veis de estado do v√≠deo
// (videoLoaded, videoAnalyzed, currentVideoBlob - j√° declaradas)

// ‚öôÔ∏è Vari√°veis de controle de comportamento
// (autoReactionEnabled, autoReactionInterval, lastReactionTime, userSelectedMood, ttsEnabled - j√° declaradas)

// --- Manipuladores de Eventos (Upload, Drag/Drop, etc.) ---

// üì• Lida com a sele√ß√£o de arquivo via bot√£o "Escolher arquivo"
videoUpload.addEventListener('change', (event) => {
  const file = event.target.files[0];
  if (file && file.type.startsWith('video/')) { // Verifica se √© um v√≠deo
    handleVideoFile(file);
  } else if (file) {
    updateStatus('Erro: Por favor, envie um arquivo de v√≠deo v√°lido!', true);
  }
});

// üì• Lida com o evento de arrastar arquivo sobre o label
uploadLabel.addEventListener('dragover', (e) => {
  e.preventDefault(); // Necess√°rio para permitir o 'drop'
  uploadLabel.classList.add('dragover'); // üí° Adiciona classe para feedback visual (opcional)
  // Estilos inline removidos, prefira classes CSS
});

// üì• Lida com o evento de sair da √°rea do label ao arrastar
uploadLabel.addEventListener('dragleave', () => {
  uploadLabel.classList.remove('dragover');
});

// üì• Lida com o evento de soltar o arquivo sobre o label
uploadLabel.addEventListener('drop', (e) => {
  e.preventDefault(); // Previne que o navegador abra o arquivo
  uploadLabel.classList.remove('dragover');

  if (e.dataTransfer.files.length) {
    const file = e.dataTransfer.files[0];
    if (file.type.startsWith('video/')) {
      // Define o arquivo no input (como se tivesse sido selecionado)
      videoUpload.files = e.dataTransfer.files;
      handleVideoFile(file); // Processa o arquivo
    } else {
      updateStatus('Erro: Apenas arquivos de v√≠deo s√£o suportados!', true);
    }
  }
});

// ‚ôªÔ∏è Fun√ß√£o central para processar o arquivo de v√≠deo carregado
function handleVideoFile(file) {
  // Libera o Blob URL anterior, se existir, para evitar memory leaks
  if (currentVideoBlob) {
    URL.revokeObjectURL(currentVideoBlob);
  }

  currentVideoBlob = URL.createObjectURL(file); // Cria uma URL tempor√°ria para o arquivo
  videoPlayer.src = currentVideoBlob; // Define a URL no player
  videoPlayer.style.display = 'block'; // Mostra o player
  unloadVideoButton.classList.remove('hidden'); // Mostra o bot√£o de remover
  uploadLabel.style.display = 'none'; // Esconde o label de upload

  videoLoaded = true;
  videoAnalyzed = false; // Resetado a cada novo v√≠deo

  updateStatus(`V√≠deo "${file.name}" carregado! ${currentCharacter.name} reagir√° automaticamente.`);
  updateDebugInfo("V√≠deo carregado. Aguardando play para iniciar an√°lise/rea√ß√µes.");

  stopIdleChat(); // Para o chat ocioso
  stopAmbientChat(); // Para o chat ambiente (de pausa)
  startAutoReactions(); // Inicia as rea√ß√µes autom√°ticas (se habilitadas)

  // Remove listeners antigos para evitar duplica√ß√£o se um novo v√≠deo for carregado
  videoPlayer.removeEventListener('play', handleVideoPlay);
  videoPlayer.removeEventListener('ended', handleVideoEnd);
  videoPlayer.removeEventListener('pause', handleVideoPause);

  // Adiciona listeners para eventos do player
  videoPlayer.addEventListener('play', handleVideoPlay);
  videoPlayer.addEventListener('ended', handleVideoEnd);
  videoPlayer.addEventListener('pause', handleVideoPause);

  // Gera uma rea√ß√£o inicial ao carregar (ap√≥s um pequeno delay)
  setTimeout(generateReaction, 500);
}

// üì¢ Atualiza a mensagem de status na UI
function updateStatus(message, isError = false) {
  if (statusMessage) { // Verifica se o elemento existe
      // Adiciona um maneirismo felino aleat√≥rio se n√£o for um erro e a mensagem mencionar o personagem
      const mentionPattern = new RegExp(`\\b${currentCharacter.name}\\b`, 'i'); // Case-insensitive check for name
      if (!isError && mentionPattern.test(message) && !message.includes('*')) { // Evita adicionar se j√° tiver um '*'
          const mannerisms = ['*abana o rabo*', '*mexe as orelhas*', '*pisca lentamente*', '*boceja*', '*se espregui√ßa*'];
          message += ` ${mannerisms[Math.floor(Math.random() * mannerisms.length)]}`;
      }
      statusMessage.textContent = message;
      statusMessage.style.color = isError ? '#ff4466' : (options.darkMode ? '#ccc' : '#666');
  }
}

// üóëÔ∏è Lida com a remo√ß√£o (descarregamento) do v√≠deo
unloadVideoButton.addEventListener('click', () => {
  if (videoPlayer) {
    videoPlayer.pause(); // Pausa antes de limpar
    videoPlayer.removeAttribute('src'); // Remove a source
    videoPlayer.load(); // For√ßa o navegador a recarregar (limpar o buffer)
    videoPlayer.style.display = 'none'; // Esconde o player
  }
  if (currentVideoBlob) {
    URL.revokeObjectURL(currentVideoBlob); // Libera a URL do Blob da mem√≥ria
    currentVideoBlob = null;
  }
  uploadLabel.style.display = 'block'; // Mostra o label de upload
  unloadVideoButton.classList.add('hidden'); // Esconde o bot√£o de remover

  videoLoaded = false;
  videoAnalyzed = false;
  stopAutoReactions(); // Para as rea√ß√µes autom√°ticas
  stopAmbientChat();   // Para o chat ambiente
  startIdleChat();     // Inicia o chat ocioso
  speechBubble.classList.add('hidden'); // Esconde o bal√£o de fala
  updateStatus(`${currentCharacter.name} est√° aguardando um novo v√≠deo...`);
  updateDebugInfo("V√≠deo removido. Aguardando novo upload.");
});

// ‚öôÔ∏è Manipulador do toggle de rea√ß√£o autom√°tica
autoReactToggle.addEventListener('change', function() {
  autoReactionEnabled = this.checked;
  localStorage.setItem('autoReactionEnabled', autoReactionEnabled); // üíæ Salva prefer√™ncia

  if (autoReactionEnabled && videoLoaded && !videoPlayer.paused) { // Se ativou E tem v√≠deo E v√≠deo est√° tocando
    startAutoReactions();
    updateStatus(`Rea√ß√µes autom√°ticas de ${currentCharacter.name} ativadas!`);
  } else {
    stopAutoReactions(); // Para as rea√ß√µes se desativou OU n√£o tem v√≠deo tocando
    if (this.checked) {
      updateStatus(`Rea√ß√µes autom√°ticas de ${currentCharacter.name} ativadas (aguardando v√≠deo ou play).`);
    } else {
      updateStatus(`Rea√ß√µes autom√°ticas de ${currentCharacter.name} desativadas.`);
    }
  }
});

// ‚öôÔ∏è Manipulador da sele√ß√£o manual de humor
moodSelect.addEventListener('change', function() {
  userSelectedMood = this.value;
  localStorage.setItem('userSelectedMood', userSelectedMood); // üíæ Salva prefer√™ncia

  if (userSelectedMood !== 'auto') {
    // Se um humor foi for√ßado, gera uma rea√ß√£o imediatamente com esse humor
    const mood = userSelectedMood;
    const moodPosition = getMoodPosition(mood);
    // ü§ñ Gera rea√ß√£o da IA com o humor selecionado, sem dados de frame ou texto extra√≠do
    generateAIReaction(mood, null, "")
      .then(reactionTextContent => {
        displayBlakeReaction({
          mood: mood,
          text: reactionTextContent,
          moodPosition: moodPosition // üí° Posi√ß√£o ideal, n√£o o valor atual
        });
      })
      .catch(error => {
        console.error("Erro ao gerar rea√ß√£o para humor manual:", error);
        updateStatus(`Erro ao gerar rea√ß√£o para ${mood}.`, true);
      });
    updateStatus(`Humor de ${currentCharacter.name} definido manualmente para ${mood}.`);
    // Pausa rea√ß√µes autom√°ticas se um humor manual foi selecionado
    stopAutoReactions();
    autoReactToggle.checked = false; // Desmarca o toggle visualmente
    autoReactionEnabled = false;
  } else {
    // Se voltou para 'Autom√°tico', reativa as rea√ß√µes autom√°ticas se aplic√°vel
    updateStatus(`${currentCharacter.name} reagir√° automaticamente ao v√≠deo.`);
    autoReactToggle.checked = true;
    autoReactionEnabled = true;
    if (videoLoaded && !videoPlayer.paused) {
      startAutoReactions();
    }
  }
});

// ‚öôÔ∏è Manipulador do toggle de Text-to-Speech (TTS)
ttsToggle.addEventListener('change', function() {
  ttsEnabled = this.checked;
  localStorage.setItem('ttsEnabled', ttsEnabled); // üíæ Salva prefer√™ncia
  updateStatus(ttsEnabled ?
    `Texto para Fala ativado. ${currentCharacter.name} agora falar√° suas rea√ß√µes.` :
    "Texto para Fala desativado.");
  // Se desativou durante uma fala, cancela
  if (!ttsEnabled && window.speechSynthesis) {
    window.speechSynthesis.cancel();
  }
});

// üó£Ô∏è Fun√ß√£o para falar o texto usando a API de S√≠ntese de Voz do navegador
function speakText(text) {
  // Verifica se TTS est√° habilitado e se a API est√° dispon√≠vel
  if (!ttsEnabled || !window.speechSynthesis) return;

  window.speechSynthesis.cancel(); // Cancela qualquer fala anterior para evitar sobreposi√ß√£o

  const utterance = new SpeechSynthesisUtterance(text);
  utterance.pitch = 1.1; // Tom de voz (mais agudo)
  utterance.rate = 1.1; // Velocidade da fala (um pouco mais r√°pido)
  utterance.lang = 'pt-BR'; // Define o idioma para portugu√™s do Brasil

  // üí° Tenta encontrar uma voz espec√≠fica (mas nomes variam entre navegadores/sistemas)
  const voices = window.speechSynthesis.getVoices();
  // Prioriza vozes masculinas em pt-BR, depois pt, depois en-US masculina, depois qualquer pt, depois a primeira dispon√≠vel
  const preferredVoice = voices.find(v => v.lang === 'pt-BR' && v.name.toLowerCase().includes('male')) ||
                         voices.find(v => v.lang === 'pt-BR') ||
                         voices.find(v => v.lang.startsWith('pt') && v.name.toLowerCase().includes('male')) ||
                         voices.find(v => v.lang.startsWith('pt')) ||
                         voices.find(v => v.lang === 'en-US' && v.name.toLowerCase().includes('male')) ||
                         voices[0]; // Fallback para a primeira voz dispon√≠vel

  if (preferredVoice) {
      utterance.voice = preferredVoice;
      // console.log("Voz TTS selecionada:", preferredVoice.name, preferredVoice.lang);
  }

  window.speechSynthesis.speak(utterance); // Inicia a fala
}

// ‚ñ∂Ô∏è Inicia o intervalo de rea√ß√µes autom√°ticas
function startAutoReactions() {
  stopAutoReactions(); // Garante que n√£o haja intervalos duplicados
  if (autoReactionEnabled && videoLoaded && !videoPlayer.paused) { // S√≥ inicia se habilitado, com v√≠deo e tocando
    generateReaction(); // Gera uma rea√ß√£o imediata
    // Define um intervalo aleat√≥rio entre 5 e 10 segundos para a pr√≥xima rea√ß√£o
    autoReactionInterval = setInterval(generateReaction, 5000 + Math.random() * 5000);
  }
}

// ‚èπÔ∏è Para o intervalo de rea√ß√µes autom√°ticas
function stopAutoReactions() {
  if (autoReactionInterval) {
    clearInterval(autoReactionInterval);
    autoReactionInterval = null;
  }
}

// --- L√≥gica da IA e Rea√ß√µes ---

// üß† Simula a an√°lise do frame atual do v√≠deo pela IA
async function analyzeVideoWithAI() {
  try {
    // Define o humor: usa o selecionado pelo usu√°rio ou escolhe um aleat√≥rio
    const targetMood = (userSelectedMood !== 'auto') ? userSelectedMood : getRandomMoodWeighted();

    let frameDataUrl = null;
    let extractedText = "";

    // Tenta capturar o frame atual se o v√≠deo estiver carregado e tocando
    if (videoLoaded && videoPlayer.readyState >= 2 && videoPlayer.videoWidth > 0 && videoPlayer.currentTime > 0) { // readyState >= 2 (HAVE_CURRENT_DATA)
      const canvas = document.createElement('canvas');
      canvas.width = videoPlayer.videoWidth;
      canvas.height = videoPlayer.videoHeight;
      const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Otimiza√ß√£o opcional
      ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
      frameDataUrl = canvas.toDataURL('image/jpeg', 0.7); // Qualidade 0.7 para reduzir tamanho

      // ü§ñ Extrai texto e descreve o frame em paralelo (se houver frame)
      // üí° Limitar chamadas √† API se forem muito frequentes
      if (Date.now() - lastReactionTime > 1000) { // Limita a an√°lise completa a cada 1 segundo
        updateDebugInfo(`Analisando frame... Mood alvo: ${targetMood}`);
        const [description, extractedTextResult] = await Promise.all([
          describeFrame(frameDataUrl),
          extractTextFromFrame(frameDataUrl)
        ]);
        extractedText = extractedTextResult;
        updateDebugInfo(`An√°lise Frame: ${description || 'N/A'}. Texto: "${extractedText || 'Nenhum'}". Mood Alvo: ${targetMood}`);

        // Dispara mensagens de chat da IA baseadas no texto extra√≠do
        if (extractedText && extractedText.trim() !== "") {
          triggerAIChatMessages(extractedText);
        }
      }
    } else {
        updateDebugInfo(`V√≠deo n√£o pronto para an√°lise. Mood alvo: ${targetMood}`);
    }

    // ü§ñ Gera a rea√ß√£o da IA (sempre tenta gerar, mesmo sem frame)
    let reactionTextContent = await generateAIReaction(targetMood, frameDataUrl, extractedText);

    // Calcula a posi√ß√£o "ideal" na barra para o humor gerado
    const moodPosition = getMoodPosition(targetMood);

    return {
      mood: targetMood,
      text: reactionTextContent,
      moodPosition: moodPosition // Posi√ß√£o ideal, n√£o o valor atual
    };

  } catch (error) {
    console.error('Erro na an√°lise pela IA:', error);
    updateDebugInfo(`‚ö†Ô∏è Erro na an√°lise: ${error.message}`);
    // Retorna um objeto de rea√ß√£o de fallback
     const fallbackMood = 'sad'; // Humor de erro
     const fallbackPhrases = blakeMoods[fallbackMood].phrases;
     const fallbackText = `Oops! Deu ruim na minha an√°lise... ${fallbackPhrases[Math.floor(Math.random() * fallbackPhrases.length)]}`;
     return {
        mood: fallbackMood,
        text: fallbackText,
        moodPosition: getMoodPosition(fallbackMood)
    };
  }
}

// ü§ñ Fun√ß√£o para extrair texto do frame usando a API Websim
async function extractTextFromFrame(frameDataUrl) {
  if (!frameDataUrl) return ""; // Retorna vazio se n√£o houver frame
  try {
    const completion = await window.websim.ai.vision.chat.completions.create({ // üí° Usando API correta?
      messages: [
        {
          role: "system",
          content: "Voc√™ √© um assistente de extra√ß√£o de texto. Sua tarefa √© extrair e retornar APENAS o texto vis√≠vel na imagem. Se n√£o houver texto √≥bvio, retorne uma string vazia. N√£o adicione nenhuma explica√ß√£o ou formata√ß√£o."
        },
        {
          role: "user",
          content: [ { type: "image_url", image_url: { url: frameDataUrl } } ]
        }
      ]
    });
    let extracted = completion.choices[0].message.content.trim();
    // console.log("Texto Extra√≠do:", extracted);
    return extracted;
  } catch (error) {
    console.error('Erro ao extrair texto do frame:', error);
    updateDebugInfo(`‚ö†Ô∏è Erro extra√ß√£o texto: ${error.message}`);
    return ""; // Retorna string vazia em caso de erro
  }
}

// ‚ú® Fun√ß√£o para descrever o frame usando a API Websim
async function describeFrame(frameDataUrl) {
  if (!frameDataUrl) return "Sem frame para descrever.";
  try {
    const completion = await window.websim.ai.vision.chat.completions.create({ // üí° Usando API correta?
      messages: [
        {
          role: "system",
          content: "Voc√™ √© um assistente de descri√ß√£o de imagens. Descreva a imagem fornecida de forma concisa (1 frase curta), focando nos elementos e a√ß√µes principais. Responda em portugu√™s brasileiro."
        },
        {
          role: "user",
          content: [ { type: "image_url", image_url: { url: frameDataUrl } } ]
        }
      ]
    });
    return completion.choices[0].message.content.trim();
  } catch (error) {
    console.error('Erro ao descrever frame:', error);
    updateDebugInfo(`‚ö†Ô∏è Erro descri√ß√£o frame: ${error.message}`);
    return "Descri√ß√£o indispon√≠vel.";
  }
}

// ü§ñ Fun√ß√£o para gerar a rea√ß√£o da IA usando a API Websim
async function generateAIReaction(mood, frameDataUrl, extractedText) {
  try {
    // Ajuste da for√ßa da resposta (sarcasmo/intensidade)
    const strengthAdjustment = (options.responseStrength - 5) * 0.1; // Varia de -0.4 a +0.5
    const sassLevel = Math.max(0.1, Math.min(1.0, 0.5 + strengthAdjustment)); // Garante entre 0.1 e 1.0

    // Prompt do sistema definindo o personagem e a tarefa
    let systemPromptContent = `Voc√™ √© ${currentCharacter.name}, ${currentCharacter.personality}.
      Voc√™ est√° assistindo a um v√≠deo e precisa reagir.
      Seu humor atual √©: ${mood}.
      Seu n√≠vel de atrevimento/sarcasmo √© ${sassLevel.toFixed(1)} (0.1=leve, 1.0=muito).
      Gere uma rea√ß√£o CURTA e ESPIRITUOSA (m√°x 2 frases) no estilo casual de rede social. Use maneirismos felinos (miados, ronronados, etc.) e g√≠rias da internet ocasionalmente. Comente sobre conte√∫do LGBTQ+ se relevante.
      Se houver texto vis√≠vel no v√≠deo, comente sobre ele DIRETAMENTE na sua rea√ß√£o.
      Responda em PORTUGU√äS BRASILEIRO. N√ÉO use markdown ou hashtags.`;

    // Conte√∫do do usu√°rio: texto + imagem (se dispon√≠vel)
    let userMessages = [];
    const textInstruction = extractedText ?
      `O v√≠deo mostra este texto: "${extractedText}". Qual sua rea√ß√£o ao frame e ao texto?` :
      "Qual sua rea√ß√£o a este frame do v√≠deo?";

    if (frameDataUrl) {
        userMessages.push({ type: "text", text: textInstruction });
        userMessages.push({ type: "image_url", image_url: { url: frameDataUrl } });
    } else {
        // Se n√£o houver frame, pede uma rea√ß√£o baseada apenas no humor
        userMessages.push({ type: "text", text: `Sem imagem dispon√≠vel. Como ${currentCharacter.name} reagiria estando ${mood}?` });
    }

    // Chamada √† API
    const completion = await window.websim.ai.vision.chat.completions.create({ // üí° Usando API correta?
        model: "gpt-4-vision-preview", // üí° Especificar modelo, se necess√°rio
        max_tokens: 70, // üí° Limitar tokens para rea√ß√µes curtas
        messages: [
            { role: "system", content: systemPromptContent },
            { role: "user", content: userMessages }
        ]
    });

    let reaction = completion.choices[0].message.content.trim();
    // console.log(`Rea√ß√£o IA (${mood}): ${reaction}`);
    return reaction;

  } catch (error) {
    console.error('Erro ao gerar rea√ß√£o da IA:', error);
    updateDebugInfo(`‚ö†Ô∏è Erro rea√ß√£o IA: ${error.message}`);
    // Fallback: usa uma frase pr√©-definida do humor correspondente
    const phrases = blakeMoods[mood]?.phrases || blakeMoods.normal.phrases;
    let fallbackReaction = phrases[Math.floor(Math.random() * phrases.length)];
    return fallbackReaction;
  }
}


// ‚ú® Exibe a rea√ß√£o do personagem na UI
function displayBlakeReaction(reactionDetails) {
  const { mood, text, moodPosition } = reactionDetails; // moodPosition n√£o √© usado para atualizar valor, s√≥ para c√°lculo inicial

  // Atualiza imagem do personagem
  if (blakeImage && blakeMoods[mood]) {
    blakeImage.src = blakeMoods[mood].image;
    blakeImage.alt = `${currentCharacter.name} - ${mood}`;
  }

  // Atualiza texto no bal√£o de fala
  if (reactionText) {
    reactionText.textContent = text;
  }
  if (speechBubble) {
    speechBubble.classList.remove('hidden'); // Mostra o bal√£o
  }

  updateMoodMeter(mood); // Atualiza o valor e a barra de humor

  // üí¨ Adiciona a rea√ß√£o ao chat como uma mensagem do personagem
  addChatMessage(currentCharacter.name, text, '#ff66cc', blakeMoods[mood]?.image || blakeMoods.normal.image);

  // üó£Ô∏è Fala a rea√ß√£o se TTS estiver habilitado
  speakText(text);
}

// üîÑ Fun√ß√£o principal para gerar uma rea√ß√£o (manual ou autom√°tica)
async function generateReaction() {
  // Previne rea√ß√µes autom√°ticas muito r√°pidas se o modo for autom√°tico
  if (userSelectedMood === 'auto' && Date.now() - lastReactionTime < 3000) return;

  lastReactionTime = Date.now(); // Atualiza a hora da √∫ltima rea√ß√£o

  try {
    updateStatus(`${currentCharacter.name} est√° pensando... *orelhas se mexem*`);
    reactButton.disabled = true; // Desabilita bot√£o manual durante processamento

    const reactionDetails = await analyzeVideoWithAI(); // Chama a IA
    displayBlakeReaction(reactionDetails); // Exibe a rea√ß√£o

    // üìú Adiciona ao hist√≥rico de rea√ß√µes AO V√çDEO
    if (reactionHistory.length === 0 || reactionHistory[reactionHistory.length - 1].text !== reactionDetails.text) {
      reactionHistory.push(reactionDetails);
      if (reactionHistory.length > MAX_REACTION_HISTORY_LENGTH) {
        reactionHistory.shift(); // Remove a mais antiga se o hist√≥rico estiver cheio
      }
    }

    retryAttempts = 0; // Reseta contador de tentativas em caso de sucesso

  } catch (error) {
    console.error('Falha ao gerar rea√ß√£o:', error);
    retryAttempts++;

    if (retryAttempts <= options.maxRetries) {
      updateStatus(`Erro ao obter rea√ß√£o de ${currentCharacter.name}. Tentando de novo (${retryAttempts}/${options.maxRetries})... *franze o nariz*`, true);
      // Tenta novamente com um delay crescente
      setTimeout(generateReaction, 1500 * retryAttempts);
    } else {
      updateStatus(`N√£o consegui reagir ap√≥s ${options.maxRetries} tentativas. ${currentCharacter.name} est√° confuso. *inclina a cabe√ßa*`, true);
      // Usa uma rea√ß√£o de fallback triste se a IA falhar consistentemente
      displayBlakeReaction({
        mood: 'sad',
        text: blakeMoods.sad.phrases[Math.floor(Math.random() * blakeMoods.sad.phrases.length)],
        moodPosition: getMoodPosition('sad')
      });
      retryAttempts = 0; // Reseta para futuras tentativas
    }
  } finally {
      // Reabilita o bot√£o de rea√ß√£o manual APENAS se as rea√ß√µes autom√°ticas estiverem DESLIGADAS
      if (!autoReactionEnabled && reactButton) {
           reactButton.disabled = false;
      }
  }
}

// --- Manipuladores de Eventos do Player de V√≠deo ---

// ‚ñ∂Ô∏è Chamado quando o v√≠deo come√ßa a tocar ou retoma ap√≥s pausa
function handleVideoPlay() {
  updateStatus(`${currentCharacter.name} est√° assistindo...`);
  stopIdleChat(); // Para chat ocioso
  stopAmbientChat(); // Para chat de pausa
  if (autoReactionEnabled) {
    startAutoReactions(); // Inicia/reinicia rea√ß√µes autom√°ticas
  }
}

// ‚èπÔ∏è Chamado quando o v√≠deo termina
function handleVideoEnd() {
  updateStatus(`V√≠deo terminou. ${currentCharacter.name} espera a pr√≥xima! *se espregui√ßa*`);
  stopAutoReactions(); // Para rea√ß√µes autom√°ticas
  startIdleChat(); // Inicia chat ocioso

  // Gera uma rea√ß√£o final ap√≥s um segundo
  setTimeout(async () => {
    // Define humor final baseado no valor atual
    const finalMood = currentMoodValue > 70 ? 'happy' : (currentMoodValue < 30 ? 'sad' : 'normal');
    const reactionTextContent = await generateAIReaction(finalMood, null, "O v√≠deo acabou. Qual sua impress√£o final?");
    displayBlakeReaction({
        mood: finalMood,
        text: reactionTextContent,
        moodPosition: getMoodPosition(finalMood)
    });
  }, 1000);
}

// ‚è∏Ô∏è Chamado quando o v√≠deo √© pausado
function handleVideoPause() {
  updateStatus(`V√≠deo pausado. ${currentCharacter.name} est√° esperando... *boceja*`);
  stopAutoReactions(); // Para rea√ß√µes autom√°ticas
  stopIdleChat(); // Para chat ocioso tamb√©m
  startAmbientChat(); // Inicia chat mais frequente durante pausa
}

// --- Funcionalidade do Chat üí¨ ---

// Adiciona uma mensagem √† UI do chat
function addChatMessage(username, message, userColor = '#ffffff', avatarSrc = null, isUser = false) {
  const messageElement = document.createElement('div');
  messageElement.classList.add('chat-message');
  // Adiciona classe espec√≠fica para o usu√°rio principal ou para outros baseado no nome
  messageElement.classList.add(isUser ? 'message-user' : `message-${username.toLowerCase().replace(/\s+/g, '-')}`);

  // Define o avatar: usa o fornecido ou gera um avatar padr√£o com iniciais
  const avatar = avatarSrc || `https://ui-avatars.com/api/?name=${encodeURIComponent(username)}&background=random&color=fff&size=24`;

  messageElement.innerHTML = `
    <img src="${avatar}" alt="${username}" class="chat-avatar">
    <div>
      <span class="chat-username" style="color: ${userColor};">${username}:</span>
      <span class="chat-text">${message}</span>
    </div>
  `;
  chatMessages.appendChild(messageElement);
  // Auto-scroll para a nova mensagem
  chatMessages.scrollTop = chatMessages.scrollHeight;

  // Adiciona ao hist√≥rico para contexto da IA (exceto as pr√≥prias mensagens do Blake)
  if (username !== currentCharacter.name) {
    chatMessageHistory.push({ username, message });
    // Mant√©m o hist√≥rico com no m√°ximo MAX_CHAT_HISTORY mensagens
    if (chatMessageHistory.length > MAX_CHAT_HISTORY) {
        chatMessageHistory.shift();
    }
  }
}

// Envia a mensagem do usu√°rio no chat
async function sendUserChatMessage() {
  const messageText = chatInput.value.trim();
  if (messageText) {
    // üë§ Obt√©m informa√ß√µes do usu√°rio do Websim (ou usa fallback)
     // üí° Idealmente, o nome do usu√°rio principal tamb√©m seria configur√°vel
    const currentUser = { username: "Voc√™", avatar_url: null }; // Simulado
    const avatar = currentUser.avatar_url || `https://ui-avatars.com/api/?name=Voc%C3%AA&background=random&color=fff&size=24`;

    addChatMessage(currentUser.username, messageText, '#e0e0e0', avatar, true); // Cinza claro para o usu√°rio, isUser = true
    chatInput.value = ''; // Limpa o input

    // ü§ñ Faz a IA reagir mais rapidamente √† mensagem do usu√°rio se estiver em modo ocioso/ambiente
    if (idleChatInterval || ambientChatInterval) {
      lastChatReactionTime = Date.now() - 25000; // Reduz o delay para a pr√≥xima mensagem de IA (ex: for√ßa a acontecer em ~5s)
      // Gera uma resposta imediatamente (opcional, pode esperar o pr√≥ximo ciclo do timer)
      // generateIdleChatMessage();
    }
  }
}

// Listeners para envio de mensagem no chat (bot√£o e Enter)
sendChatButton.addEventListener('click', sendUserChatMessage);
chatInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) { // Previne envio com Shift+Enter
    e.preventDefault(); // Previne nova linha no input (se fosse textarea)
    sendUserChatMessage();
  }
});

// ü§ñ Gera e adiciona uma mensagem de chat da IA (ou participante customizado)
async function generateIdleChatMessage() {
    // N√£o gera mensagem se o v√≠deo estiver tocando
    if (videoLoaded && !videoPlayer.paused) return;
    // N√£o gera se uma mensagem/rea√ß√£o ocorreu recentemente (30s)
    if (Date.now() - lastChatReactionTime < 30000) return;

    lastChatReactionTime = Date.now(); // Atualiza o tempo da √∫ltima atividade do chat

    try {
        // Decide quem vai falar: Blake ou um dos participantes ativos
        const participants = [currentCharacter, ...activeChatters]; // Inclui o personagem principal
        const speaker = participants[Math.floor(Math.random() * participants.length)];

        // Define a personalidade e informa√ß√µes do falante
        const speakerPersonality = speaker.personality || currentCharacter.personality; // Fallback para Blake se n√£o tiver
        const speakerAvatar = speaker.customImages?.normal || // Tenta imagem normal customizada
                              speaker.image ||                // Tenta imagem customizada geral
                              (speaker.name === currentCharacter.name ? blakeMoods.normal.image : null) || // Tenta normal do Blake
                              `https://ui-avatars.com/api/?name=${encodeURIComponent(speaker.name)}&background=random&color=fff&size=24`; // Avatar padr√£o
        const speakerColor = speaker.color || (speaker.name === currentCharacter.name ? '#ff66cc' : '#aaa'); // Cor padr√£o

        // Monta o prompt do sistema para a IA
        let systemPromptContent = `Voc√™ √© ${speaker.name}, ${speakerPersonality}.
            Voc√™ est√° no chat de uma livestream de ${currentCharacter.name}.
            Baseado no hist√≥rico recente do chat, gere uma mensagem CURTA e CASUAL (1-2 frases) que voc√™ postaria.
            Mantenha o tom apropriado para um chat de livestream (pode usar emotes).
            Se o hist√≥rico estiver vazio, diga algo aleat√≥rio ou cumprimente os outros.
            Responda em PORTUGU√äS BRASILEIRO. N√ÉO use markdown ou hashtags. N√ÉO se apresente.`;

        // Monta o hist√≥rico do chat para o prompt do usu√°rio
        let userPromptContent = "Hist√≥rico recente (√∫ltimas mensagens primeiro):\n";
        if (chatMessageHistory.length > 0) {
            chatMessageHistory.slice(-5).reverse().forEach(msg => { // Pega as √∫ltimas 5
                userPromptContent += `${msg.username}: ${msg.message}\n`;
            });
        } else {
            userPromptContent += "(Nenhuma mensagem recente)\n";
        }
        userPromptContent += `\nO que ${speaker.name} diria agora no chat?`;

        // Chama a IA
        const completion = await window.websim.ai.vision.chat.completions.create({ // üí° Usando API correta?
             model: "gpt-4-turbo-preview", // üí° Modelo mais r√°pido para chat?
             max_tokens: 50,
             messages: [
                { role: "system", content: systemPromptContent },
                { role: "user", content: userPromptContent }
             ]
        });
        let chatResponse = completion.choices[0].message.content.trim();

        // Adiciona a mensagem gerada ao chat se n√£o estiver vazia
        if (chatResponse) {
             addChatMessage(speaker.name, chatResponse, speakerColor, speakerAvatar);
             updateDebugInfo(`üí¨ Chat Ocioso (${speaker.name}): ${chatResponse}`);
        }

    } catch (error) {
        console.error('Erro ao gerar mensagem de chat ocioso:', error);
        updateDebugInfo(`‚ö†Ô∏è Erro chat ocioso: ${error.message}`);
        // Fallback simples em caso de erro da IA (menos frequente)
        if (Math.random() < 0.1) {
             const phrases = ["Hmm...", "*bocejo*", "Algu√©m a√≠?", "Que t√©dio...", `Manda salve, ${currentCharacter.name}!`];
             const randomChatter = activeChatters.length > 0 ? activeChatters[Math.floor(Math.random() * activeChatters.length)] : {name: "Espectador", color: "#aaa"};
             addChatMessage(randomChatter.name, phrases[Math.floor(Math.random() * phrases.length)], randomChatter.color);
        }
    }
}

// ü§ñ Dispara mensagens de chat da IA baseadas no texto extra√≠do do v√≠deo
async function triggerAIChatMessages(extractedText) {
  if (!extractedText || extractedText.trim() === "" || extractedText.length < 3) return; // Ignora textos muito curtos

  try {
    // Usa participantes ativos ou um conjunto padr√£o se n√£o houver customizados
    const chattersToConsider = activeChatters.length > 0 ? activeChatters : [
        { name: 'Zangos', personality: 'engra√ßado e um pouco ca√≥tico', color: '#ff5722' },
        { name: 'Connie', personality: 'anal√≠tica e curiosa', color: '#2196f3' },
        { name: 'Beary', personality: 'c√≠nico mas com um bom cora√ß√£o', color: '#8bc34a' }
    ];

    // Seleciona aleatoriamente 1 ou 2 participantes para comentar sobre o texto
    const numChattersToComment = Math.random() < 0.6 ? 1 : Math.min(2, chattersToConsider.length); // Garante no m√°ximo 2 ou o total dispon√≠vel
    const selectedChatters = [];
    const availableChatters = [...chattersToConsider]; // Cria c√≥pia para n√£o modificar o original

    for (let i = 0; i < numChattersToComment && availableChatters.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * availableChatters.length);
        selectedChatters.push(availableChatters.splice(randomIndex, 1)[0]); // Adiciona e remove da lista de dispon√≠veis
    }

    // Gera e envia a mensagem para cada participante selecionado
    for (const chatter of selectedChatters) {
      const systemPromptContent = `Voc√™ √© ${chatter.name}, um espectador ${chatter.personality}.
        Voc√™ est√° assistindo √† livestream de ${currentCharacter.name}. O seguinte texto apareceu no v√≠deo: "${extractedText}".
        Gere uma rea√ß√£o CURTA e CASUAL (1 frase) a este texto, como se estivesse digitando no chat.
        Responda em PORTUGU√äS BRASILEIRO. N√ÉO use markdown ou hashtags.`;

      const completion = await window.websim.ai.vision.chat.completions.create({ // üí° Usando API correta?
        model: "gpt-4-turbo-preview",
        max_tokens: 30,
        messages: [
          { role: "system", content: systemPromptContent },
          { role: "user", content: `O que ${chatter.name} diria sobre o texto "${extractedText}"?` }
        ]
      });
      let chatterReaction = completion.choices[0].message.content.trim();

      if (chatterReaction) {
        // Adiciona a mensagem ao chat com um pequeno delay entre elas
        await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 700));
        const avatar = chatter.image || `https://ui-avatars.com/api/?name=${encodeURIComponent(chatter.name)}&background=random&color=fff&size=24`;
        addChatMessage(chatter.name, chatterReaction, chatter.color, avatar);
        updateDebugInfo(`üí¨ Rea√ß√£o Texto (${chatter.name}): ${chatterReaction}`);
      }
    }
  } catch (error) {
    console.error("Erro ao gerar coment√°rios da IA sobre o texto do v√≠deo:", error);
    updateDebugInfo(`‚ö†Ô∏è Erro rea√ß√£o texto v√≠deo: ${error.message}`);
  }
}


// üí¨ Inicia o intervalo para gerar mensagens de chat ocioso
function startIdleChat() {
  stopIdleChat(); // Garante que n√£o haja timers duplicados
  stopAmbientChat();
  // S√≥ inicia se n√£o houver v√≠deo carregado OU se o v√≠deo estiver carregado mas terminado
  if (!videoLoaded || videoPlayer.ended) {
    idleChatInterval = setInterval(generateIdleChatMessage, 25000 + Math.random() * 15000); // Intervalo maior: 25-40 segundos
  }
}

// üí¨ Para o intervalo do chat ocioso
function stopIdleChat() {
  if (idleChatInterval) {
    clearInterval(idleChatInterval);
    idleChatInterval = null;
  }
}

// üí¨ Inicia chat ambiente (mais frequente) quando o v√≠deo est√° pausado
function startAmbientChat() {
    stopAmbientChat();
    stopIdleChat(); // Para o chat ocioso normal
    // S√≥ inicia se v√≠deo carregado E pausado E n√£o terminado
    if (videoLoaded && videoPlayer.paused && !videoPlayer.ended) {
        ambientChatInterval = setInterval(generateIdleChatMessage, 15000 + Math.random() * 10000); // Intervalo menor: 15-25s
    }
}

// üí¨ Para o chat ambiente
function stopAmbientChat() {
    if (ambientChatInterval) {
        clearInterval(ambientChatInterval);
        ambientChatInterval = null;
    }
}


// --- ‚ú® Funcionalidade de Personaliza√ß√£o do Personagem ---

// Carrega personagem salvo do localStorage ao iniciar
function loadSavedCharacter() {
  const saved = localStorage.getItem('blakeReactionCharacter');
  if (saved) {
    try {
      const parsedCharacter = JSON.parse(saved);
      // Valida√ß√£o b√°sica
      if (parsedCharacter.name && parsedCharacter.personality) {
        // Merge para garantir que novas propriedades sejam adicionadas se n√£o existirem no save antigo
        currentCharacter = { ...currentCharacter, ...parsedCharacter };
        // Garante que customImages exista
        currentCharacter.customImages = currentCharacter.customImages || {};
      } else {
        console.warn("Personagem salvo inv√°lido, usando padr√£o.");
        saveCurrentCharacter(); // Salva o padr√£o se o salvo for inv√°lido
      }
    } catch (e) {
      console.error("Erro ao carregar personagem salvo:", e);
      saveCurrentCharacter(); // Salva o padr√£o em caso de erro
    }
  } else {
      // Se n√£o h√° nada salvo, salva o padr√£o inicial
      saveCurrentCharacter();
  }
  applyCharacterToUI(); // Aplica os dados carregados (ou padr√£o) √† UI
}

// Salva o estado atual de `currentCharacter` no localStorage
function saveCurrentCharacter() {
  localStorage.setItem('blakeReactionCharacter', JSON.stringify(currentCharacter));
}

// Aplica os dados do `currentCharacter` aos elementos da UI
function applyCharacterToUI() {
  if (characterNameInput) characterNameInput.value = currentCharacter.name;
  if (characterPersonalityInput) characterPersonalityInput.value = currentCharacter.personality;
  if (pageTitle) pageTitle.textContent = `Tempo de Rea√ß√£o de ${currentCharacter.name}`;

  // Atualiza todos os spans que exibem o nome do personagem
  characterNameSpans.forEach(span => {
    span.textContent = currentCharacter.name;
  });

  // Atualiza o objeto blakeMoods para refletir imagens customizadas
  blakeMoods = getCharacterMoods();

  // Atualiza as imagens de preview no painel de personaliza√ß√£o
  moodImageSelectors.forEach(selector => {
    const mood = selector.dataset.mood;
    const imgElement = selector.querySelector('img');
    if (imgElement && blakeMoods[mood]) {
      imgElement.src = blakeMoods[mood].image;
      imgElement.onerror = () => { // üí° Fallback se a imagem customizada n√£o carregar
          console.warn(`Imagem customizada para humor ${mood} n√£o encontrada, usando padr√£o.`);
          imgElement.src = getCharacterMoods()[mood].image; // Tenta recarregar a padr√£o
          currentCharacter.customImages[mood] = null; // Remove a imagem inv√°lida do save
          saveCurrentCharacter();
      };
    }
  });

  // Atualiza a imagem principal do Blake (se vis√≠vel e sem v√≠deo)
  if (blakeImage && !videoLoaded) {
     const currentSelectedMood = moodSelect.value !== 'auto' ? moodSelect.value : 'normal';
     blakeImage.src = blakeMoods[currentSelectedMood]?.image || blakeMoods.normal.image;
  }
}

// Lida com o upload de uma nova imagem para um humor espec√≠fico
async function handleMoodImageUpload(event) {
  const input = event.target;
  const mood = input.closest('.mood-image-selector').dataset.mood; // Pega o humor do elemento pai
  const file = input.files[0];

  if (file && mood) {
    // Valida√ß√£o b√°sica de tipo e tamanho (exemplo)
    if (!file.type.startsWith('image/')) {
        updateStatus(`Erro: Arquivo para humor "${mood}" n√£o √© uma imagem.`, true);
        return;
    }
    if (file.size > 2 * 1024 * 1024) { // Limite de 2MB (exemplo)
        updateStatus(`Erro: Imagem para humor "${mood}" √© muito grande (> 2MB).`, true);
        return;
    }

    try {
      updateStatus(`Enviando imagem para humor "${mood}"...`);
      // Usa a fun√ß√£o de upload do Websim (ou outra API/backend)
      // üí° Garanta que `websim.upload` esteja definida e funcional
      const imageUrl = await window.websim.upload(file);

      currentCharacter.customImages[mood] = imageUrl; // Armazena a URL da imagem hospedada
      saveCurrentCharacter(); // Salva no localStorage
      applyCharacterToUI(); // Atualiza a UI
      updateStatus(`Imagem para humor "${mood}" atualizada!`);
    } catch (error) {
      console.error(`Erro ao enviar imagem para ${mood}:`, error);
      updateStatus(`Erro ao enviar imagem para ${mood}. Tente novamente.`, true);
    } finally {
        input.value = ''; // Limpa o input de arquivo para permitir novo upload do mesmo arquivo
    }
  }
}

// Listener para o bot√£o "Salvar Personagem"
saveCharacter.addEventListener('click', () => {
  // Atualiza o objeto `currentCharacter` com os valores dos inputs
  currentCharacter.name = characterNameInput.value.trim() || 'Blake'; // Usa 'Blake' se vazio
  currentCharacter.personality = characterPersonalityInput.value.trim() || getCharacterMoods().normal.phrases[0]; // Usa frase padr√£o se vazio

  saveCurrentCharacter(); // Salva no localStorage
  applyCharacterToUI(); // Atualiza a UI
  updateStatus(`Personagem "${currentCharacter.name}" salvo com sucesso!`);

  // Opcional: Fecha o painel ap√≥s salvar
  // customizerPanel.classList.add('hidden');
  // toggleCustomizer.textContent = 'Personalizar Personagem';
});

// Listener para o bot√£o "Restaurar Padr√£o"
resetCharacter.addEventListener('click', () => {
  if (confirm(`Tem certeza que deseja restaurar ${currentCharacter.name} para as configura√ß√µes padr√£o? Todas as personaliza√ß√µes (nome, personalidade, imagens) ser√£o perdidas.`)) {
    // Redefine para o objeto padr√£o
    currentCharacter = {
      name: 'Blake',
      personality: 'um gato furry gay espirituoso e um pouco pregui√ßoso que ama conte√∫do LGBTQ+',
      customImages: {},
      description: 'Um gato furry gay espirituoso...' // Descri√ß√£o padr√£o
    };
    saveCurrentCharacter(); // Salva o padr√£o
    applyCharacterToUI(); // Aplica na UI
    updateStatus(`Personagem "${currentCharacter.name}" restaurado para o padr√£o.`);
  }
});

// --- Funcionalidade de Streaming de Personagens (WebsimSocket) ---
const STREAMING_CHARACTER_COLLECTION = 'blake_reaction_characters_v3'; // üí° v3 indica nova estrutura/reset

// Salva o personagem ATUAL na cole√ß√£o online
saveToStreamBtn.addEventListener('click', async () => {
  if (!currentCharacter.name || !currentCharacter.personality) {
    updateStatus("Defina nome e personalidade antes de salvar na transmiss√£o.", true);
    return;
  }

  try {
    updateStatus(`Salvando ${currentCharacter.name} na transmiss√£o...`);
    const currentUser = await window.websim.getUser();
    const username = currentUser?.username || 'An√¥nimo'; // Pega nome de usu√°rio do Websim ou usa 'An√¥nimo'

    // üîç Verifica se j√° existe um personagem com este nome deste usu√°rio
    const existing = await room.collection(STREAMING_CHARACTER_COLLECTION)
                            .filter({ username: username, characterName: currentCharacter.name })
                            .get(); // Pega a lista filtrada

    const dataToSave = {
        characterName: currentCharacter.name,
        characterPersonality: currentCharacter.personality,
        customImages: currentCharacter.customImages,
        description: currentCharacter.description || `Personagem de ${username}`,
        // username √© adicionado automaticamente pelo Websim ao criar/atualizar
    };

    if (existing && existing.length > 0) {
        // Atualiza o existente
        const charId = existing[0].id;
        await room.collection(STREAMING_CHARACTER_COLLECTION).update(charId, dataToSave);
        updateStatus(`${currentCharacter.name} atualizado na transmiss√£o!`);
    } else {
        // Cria um novo
        await room.collection(STREAMING_CHARACTER_COLLECTION).create(dataToSave);
        updateStatus(`${currentCharacter.name} salvo na transmiss√£o! Outros podem us√°-lo.`);
    }
  } catch (error) {
    console.error("Erro ao salvar personagem na transmiss√£o:", error);
    updateStatus("Erro ao salvar personagem online. Tente novamente.", true);
  }
});

// Carrega e se inscreve √†s atualiza√ß√µes da cole√ß√£o de personagens online
async function loadStreamingCharacters() {
  // Cancela inscri√ß√£o anterior para evitar duplicatas
  if (streamingSubscription) {
    streamingSubscription();
    streamingSubscription = null;
  }

  streamingList.innerHTML = '<p class="loading-message">Carregando personagens da transmiss√£o...</p>';

  try {
      // Se inscreve para receber atualiza√ß√µes em tempo real
      streamingSubscription = room.collection(STREAMING_CHARACTER_COLLECTION).subscribe(async (characters) => {
        // Ordena por data de cria√ß√£o (mais recentes primeiro)
        streamingCharacters = characters.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
        renderStreamingCharacters(); // Renderiza a lista atualizada
      });
  } catch (error) {
      console.error("Erro ao inscrever-se na cole√ß√£o de streaming:", error);
      streamingList.innerHTML = '<p class="no-chatters-message">Erro ao carregar personagens online.</p>';
  }
}

// Renderiza a lista de personagens em streaming na UI
async function renderStreamingCharacters() {
  if (!streamingList) return;
  streamingList.innerHTML = ''; // Limpa a lista

  const currentUser = await window.websim.getUser();
  const currentUsername = currentUser?.username; // Nome do usu√°rio logado

  if (streamingCharacters.length === 0) {
    streamingList.innerHTML = '<p class="no-chatters-message">Nenhum personagem na transmiss√£o ainda. Salve o seu!</p>';
    return;
  }

  // Cria um elemento para cada personagem
  streamingCharacters.forEach(charData => {
    const charElement = document.createElement('div');
    charElement.classList.add('streaming-character');
    const isOwnCharacter = charData.username === currentUsername; // Verifica se √© do usu√°rio atual
    if (isOwnCharacter) {
        charElement.classList.add('your-character'); // Adiciona classe especial
    }

    // Define a imagem de preview (normal ou avatar padr√£o)
    const previewImageSrc = charData.customImages?.normal || `https://ui-avatars.com/api/?name=${encodeURIComponent(charData.characterName)}&background=random&color=fff&size=50`;

    charElement.innerHTML = `
      <img src="${previewImageSrc}" alt="${charData.characterName}" class="invited-chatter-avatar">
      <div class="character-info">
        <h4>${charData.characterName} ${isOwnCharacter ? '(Seu)' : ''}</h4>
        <p>${charData.characterPersonality.substring(0, 100)}${charData.characterPersonality.length > 100 ? '...' : ''}</p>
        <p class="creator">Por: @${charData.username || 'Desconhecido'}</p>
      </div>
      <div class="character-actions">
        <button class="load-streamed-char-btn" data-id="${charData.id}">Usar</button>
        ${isOwnCharacter ? `<button class="delete-streamed-char-btn" data-id="${charData.id}">Excluir</button>` : ''}
      </div>
    `;
    streamingList.appendChild(charElement);
  });

  // Adiciona listeners aos bot√µes rec√©m-criados
  streamingList.querySelectorAll('.load-streamed-char-btn').forEach(button => {
    button.addEventListener('click', handleLoadStreamedCharacter);
  });
  streamingList.querySelectorAll('.delete-streamed-char-btn').forEach(button => {
    button.addEventListener('click', handleDeleteStreamedCharacter);
  });
}

// Carrega os dados de um personagem selecionado da lista online para o estado atual
async function handleLoadStreamedCharacter(event) {
    const charId = event.target.dataset.id;
    const charToLoad = streamingCharacters.find(c => c.id === charId);

    if (charToLoad) {
        // Atualiza o objeto `currentCharacter` com os dados carregados
        currentCharacter.name = charToLoad.characterName;
        currentCharacter.personality = charToLoad.characterPersonality;
        currentCharacter.customImages = charToLoad.customImages || {}; // Garante que seja um objeto
        currentCharacter.description = charToLoad.description || '';

        saveCurrentCharacter(); // Salva localmente
        applyCharacterToUI(); // Aplica na UI
        blakeMoods = getCharacterMoods(); // Recalcula humores com novas imagens

        updateStatus(`Personagem "${currentCharacter.name}" carregado da transmiss√£o!`);
        // Opcional: Fecha o painel
        // streamingPanel.classList.add('hidden');
    } else {
        updateStatus("Erro: N√£o foi poss√≠vel carregar o personagem selecionado.", true);
    }
}

// Exclui um personagem da cole√ß√£o online (apenas o criador pode)
async function handleDeleteStreamedCharacter(event) {
    const charId = event.target.dataset.id;
    const charToDelete = streamingCharacters.find(c => c.id === charId);

    if (charToDelete && confirm(`Tem certeza que deseja excluir "${charToDelete.characterName}" da transmiss√£o? Esta a√ß√£o N√ÉO pode ser desfeita.`)) {
        try {
            // Chama a fun√ß√£o delete da cole√ß√£o WebsimSocket
            await room.collection(STREAMING_CHARACTER_COLLECTION).delete(charId);
            updateStatus(`Personagem "${charToDelete.characterName}" exclu√≠do da transmiss√£o.`);
            // A lista ser√° atualizada automaticamente pelo 'subscribe', n√£o precisa remover manualmente
        } catch (error) {
            console.error("Erro ao excluir personagem da transmiss√£o:", error);
            updateStatus("Erro ao excluir personagem. Verifique se voc√™ √© o criador ou tente novamente.", true);
        }
    }
}

// --- Funcionalidade de Melhoria de Humor üòä ---

// Inicializa os bot√µes de boost de humor
function initMoodBoostButtons() {
  treatButton.addEventListener('click', () => applyMoodBoost('treat', 10, 30)); // +10 humor, 30s cooldown
  petButton.addEventListener('click', () => applyMoodBoost('pet', 15, 60));     // +15 humor, 60s cooldown
  complimentButton.addEventListener('click', () => applyMoodBoost('compliment', 20, 90)); // +20 humor, 90s cooldown
  updateBoostCooldowns(); // Atualiza estado inicial dos bot√µes
  // Inicia o timer de cooldown a cada segundo
  setInterval(decreaseCooldowns, 1000);
}

// Aplica o boost de humor e inicia o cooldown
function applyMoodBoost(type, amount, cooldownSeconds) {
  if (boostCooldowns[type] > 0) { // Verifica se est√° em cooldown
    updateStatus(`${currentCharacter.name} ainda est√° curtindo o √∫ltimo ${getBoostTypeName(type)}! Espere um pouco.`, true);
    return;
  }

  // Aplica o boost ao humor atual, limitando a 100
  currentMoodValue = Math.min(100, currentMoodValue + amount);
  updateMoodMeter('happy'); // Atualiza a barra (passando 'happy' para for√ßar o c√°lculo do impacto visual)
                            // A fun√ß√£o updateMoodMeter agora n√£o altera o valor se userSelectedMood != 'auto',
                            // mas ainda atualiza a barra visualmente.
                            // Poder√≠amos chamar `updateMoodVisuals()` diretamente.
  updateMoodVisuals(); // Atualiza diretamente a barra e o texto

  // Define a rea√ß√£o de acordo com o tipo de boost
  let reactionText = "";
  switch(type) {
      case 'treat': reactionText = `Nhom! Que del√≠cia! Obg pelo agrado! *ronrona feliz*`; break;
      case 'pet': reactionText = `Awnnn, que carinho bom! N√£o para, humano! *se esfrega pedindo mais*`; break;
      case 'compliment': reactionText = `Owwwn, voc√™ acha? Que fofo! Assim eu fico sem gra√ßa... *corado e abanando o rabo*`; break;
  }

  // Exibe a rea√ß√£o feliz
  displayBlakeReaction({
      mood: 'happy', // Mostra imagem feliz
      text: reactionText,
      moodPosition: 85 // Posi√ß√£o ideal para feliz
  });

  // Inicia o cooldown para este tipo de boost
  boostCooldowns[type] = cooldownSeconds;
  updateBoostButton(type); // Atualiza o bot√£o espec√≠fico
}

// Atualiza a apar√™ncia de UM bot√£o de boost (habilita/desabilita e mostra timer)
function updateBoostButton(type) {
    const button = document.getElementById(`${type}-button`);
    const cooldownSpan = document.getElementById(`${type}-cooldown`);
    if (!button || !cooldownSpan) return;

    if (boostCooldowns[type] > 0) {
        button.disabled = true;
        cooldownSpan.textContent = `(${boostCooldowns[type]}s)`;
    } else {
        button.disabled = false;
        cooldownSpan.textContent = '';
    }
}

// Atualiza a apar√™ncia de TODOS os bot√µes de boost
function updateBoostCooldowns() {
  Object.keys(boostCooldowns).forEach(type => updateBoostButton(type));
}

// Decrementa os timers de cooldown a cada segundo
function decreaseCooldowns() {
    let needsUpdate = false;
    Object.keys(boostCooldowns).forEach(type => {
        if (boostCooldowns[type] > 0) {
            boostCooldowns[type]--;
            needsUpdate = true;
        }
    });
    if (needsUpdate) {
        updateBoostCooldowns(); // Atualiza a UI se algum timer mudou
    }
}

// Retorna o nome do tipo de boost em portugu√™s
function getBoostTypeName(type) {
    switch(type) {
        case 'treat': return 'agrado';
        case 'pet': return 'carinho';
        case 'compliment': return 'elogio';
        default: return 'boost';
    }
}

// Fun√ß√£o separada para atualizar apenas os visuais do humor (barra e texto)
function updateMoodVisuals() {
    if (moodMeterFill) {
        moodMeterFill.style.width = `${currentMoodValue}%`;
    }
    if (moodValue) {
        moodValue.textContent = `${currentMoodValue}%`;
        moodValue.style.color = getMoodColor(currentMoodValue);
    }
}


// --- Funcionalidade do Modal de Participantes Customizados üë§ ---

// Inicializa os listeners e carrega dados para o modal
function initCustomChattersFeature() {
    loadCustomChatters(); // Carrega do localStorage
    renderInvitedChattersList(); // Exibe na aba "Convidados"

    // Abrir modal
    addChatterBtn.addEventListener('click', () => customChattersModal.classList.add('active'));
    // Fechar modal
    closeModalBtn.addEventListener('click', () => customChattersModal.classList.remove('active'));
    // Fechar modal clicando fora (no overlay) - Adicionado
    customChattersModal.addEventListener('click', (e) => {
        if (e.target === customChattersModal) { // S√≥ fecha se clicar no fundo, n√£o no conte√∫do
            customChattersModal.classList.remove('active');
        }
    });


    // Troca de abas no modal
    modalTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            modalTabs.forEach(t => t.classList.remove('active')); // Desativa todas
            tabContents.forEach(c => c.classList.remove('active')); // Esconde todos conte√∫dos
            tab.classList.add('active'); // Ativa a clicada
            document.getElementById(tab.dataset.tab).classList.add('active'); // Mostra conte√∫do correspondente
        });
    });

    // Preview da imagem ao selecionar arquivo
    chatterImageUpload.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (e) => chatterImagePreview.src = e.target.result;
            reader.readAsDataURL(file);
        } else if (file) {
            alert("Por favor, selecione um arquivo de imagem v√°lido.");
            chatterImagePreview.src = 'https://ui-avatars.com/api/?name=?&background=random&color=fff'; // Reset preview
        }
    });

    // Preview da cor ao selecionar
    chatterColorInput.addEventListener('input', (e) => colorPreview.style.backgroundColor = e.target.value);

    // Submiss√£o do formul√°rio de cria√ß√£o
    chatterForm.addEventListener('submit', handleChatterFormSubmit);
}

// Carrega participantes salvos do localStorage
function loadCustomChatters() {
    const saved = localStorage.getItem(CUSTOM_CHATTERS_STORAGE_KEY);
    if (saved) {
        try {
            customChatters = JSON.parse(saved);
            // Inicializa a lista de ativos (pode ser carregada de outro lugar no futuro)
            activeChatters = customChatters.filter(c => c.isActive); // Assumindo que ter√≠amos um campo 'isActive'
                                                                   // Por agora, vamos come√ßar sem ningu√©m ativo
            activeChatters = [];
        } catch (e) {
            console.error("Erro ao carregar participantes customizados:", e);
            customChatters = [];
            activeChatters = [];
        }
    }
    updateViewersCount(); // Atualiza contagem inicial (base + ativos)
}

// Salva a lista atual de participantes no localStorage
function saveCustomChatters() {
    localStorage.setItem(CUSTOM_CHATTERS_STORAGE_KEY, JSON.stringify(customChatters));
}

// Renderiza a lista na aba "Participantes Convidados" do modal
function renderInvitedChattersList() {
    invitedChattersList.innerHTML = ''; // Limpa a lista

    if (customChatters.length === 0) {
        invitedChattersList.innerHTML = '<p class="no-chatters-message">Nenhum participante personalizado criado.</p>';
        return;
    }

    // Cria um elemento para cada participante salvo
    customChatters.forEach(chatter => {
        const chatterElement = document.createElement('div');
        chatterElement.classList.add('invited-chatter');
        const isChatterActive = activeChatters.some(ac => ac.id === chatter.id); // Verifica se est√° ativo

        chatterElement.innerHTML = `
            <img src="${chatter.image || `https://ui-avatars.com/api/?name=${encodeURIComponent(chatter.name)}&background=random&color=fff&size=50`}" alt="${chatter.name}" class="invited-chatter-avatar">
            <div class="invited-chatter-info">
                <h4 class="invited-chatter-name">${chatter.name} <span class="invited-chatter-color" style="background-color:${chatter.color};"></span></h4>
                <p class="invited-chatter-personality">${chatter.personality.substring(0, 80)}${chatter.personality.length > 80 ? '...' : ''}</p>
            </div>
            <div class="invited-chatter-actions">
                ${!isChatterActive
                    ? `<button class="invite-chatter-btn" data-id="${chatter.id}">Convidar</button>`
                    : `<button class="kick-chatter-btn" data-id="${chatter.id}">Expulsar</button>`}
                <button class="remove-chatter-btn" data-id="${chatter.id}">Excluir</button>
            </div>
        `;
        invitedChattersList.appendChild(chatterElement);
    });

    // Adiciona listeners aos bot√µes rec√©m-criados
    invitedChattersList.querySelectorAll('.invite-chatter-btn').forEach(btn => btn.addEventListener('click', handleInviteChatter));
    invitedChattersList.querySelectorAll('.kick-chatter-btn').forEach(btn => btn.addEventListener('click', handleKickChatter));
    invitedChattersList.querySelectorAll('.remove-chatter-btn').forEach(btn => btn.addEventListener('click', handleRemoveChatter));
}

// Adiciona um participante customizado ao chat ativo
function addChatterToLiveChat(chatter) {
    // Verifica se j√° n√£o est√° ativo
    if (!activeChatters.some(ac => ac.id === chatter.id)) {
        activeChatters.push(chatter); // Adiciona √† lista de ativos
        viewersCount++; // Incrementa contador visual
        updateViewersCount();
        addChatMessage('Sistema', `${chatter.name} entrou no chat!`, '#aaa'); // Mensagem de sistema
        renderInvitedChattersList(); // Re-renderiza a lista no modal para atualizar o bot√£o para "Expulsar"
    }
}

// Remove (expulsa) um participante customizado do chat ativo
function kickChatterFromLiveChat(chatterId) {
    const chatterIndex = activeChatters.findIndex(ac => ac.id === chatterId);
    if (chatterIndex > -1) { // Se encontrou na lista de ativos
        const chatter = activeChatters[chatterIndex];
        activeChatters.splice(chatterIndex, 1); // Remove da lista de ativos
        viewersCount--; // Decrementa contador visual
        updateViewersCount();
        addChatMessage('Sistema', `${chatter.name} saiu do chat.`, '#aaa'); // Mensagem de sistema
        renderInvitedChattersList(); // Re-renderiza a lista no modal para atualizar o bot√£o para "Convidar"
    }
}

// Exclui permanentemente um participante customizado
function removeCustomChatter(chatterId) {
    const chatterToRemove = customChatters.find(c => c.id === chatterId);
    if (chatterToRemove && confirm(`Tem certeza que quer excluir permanentemente o participante "${chatterToRemove.name}"?`)) {
        kickChatterFromLiveChat(chatterId); // Garante que saiu do chat ativo
        customChatters = customChatters.filter(c => c.id !== chatterId); // Remove da lista principal
        saveCustomChatters(); // Salva a lista atualizada no localStorage
        renderInvitedChattersList(); // Re-renderiza a lista no modal
    }
}

// Handlers para os bot√µes na lista de convidados
function handleInviteChatter(event) {
    const chatter = customChatters.find(c => c.id === event.target.dataset.id);
    if (chatter) addChatterToLiveChat(chatter);
}
function handleKickChatter(event) {
    kickChatterFromLiveChat(event.target.dataset.id);
}
function handleRemoveChatter(event) {
    removeCustomChatter(event.target.dataset.id);
}

// Processa a submiss√£o do formul√°rio de cria√ß√£o de participante
async function handleChatterFormSubmit(event) {
    event.preventDefault(); // Previne envio padr√£o
    const name = chatterNameInput.value.trim();
    const personality = chatterPersonalityInput.value.trim();
    const color = chatterColorInput.value;
    const imageFile = chatterImageUpload.files[0];

    if (!name || !personality) {
        alert("Nome e personalidade s√£o obrigat√≥rios!");
        return;
    }

    // Usa avatar padr√£o inicialmente
    let imageUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=random&color=fff`;

    // Se uma imagem foi selecionada, tenta fazer o upload
    if (imageFile) {
        // Valida√ß√£o de imagem (opcional mas recomendado)
        if (!imageFile.type.startsWith('image/') || imageFile.size > 2 * 1024 * 1024) {
            alert("Por favor, selecione um arquivo de imagem v√°lido (JPG, PNG, GIF) menor que 2MB.");
            return; // Interrompe se a imagem for inv√°lida
        }
        try {
            updateStatus("Enviando imagem do participante..."); // Feedback visual
            // üí° Substituir `window.websim.upload` pela sua fun√ß√£o de upload real
            imageUrl = await window.websim.upload(imageFile);
            updateStatus("Imagem do participante enviada!");
        } catch (error) {
            console.error("Erro ao enviar imagem do participante:", error);
            updateStatus("Erro ao enviar imagem. Usando avatar padr√£o.", true);
            // Continua com o avatar padr√£o se o upload falhar
        }
    }

    // Cria o novo objeto participante
    const newChatter = {
        id: Date.now().toString(), // ID simples baseado no timestamp
        name,
        personality,
        image: imageUrl, // URL da imagem (do upload ou padr√£o)
        color
    };

    customChatters.push(newChatter); // Adiciona √† lista principal
    saveCustomChatters(); // Salva no localStorage
    addChatterToLiveChat(newChatter); // Adiciona automaticamente ao chat ativo

    // Limpa o formul√°rio e reseta previews
    chatterForm.reset();
    chatterImagePreview.src = 'https://ui-avatars.com/api/?name=Novo+Participante&background=random&color=fff';
    colorPreview.style.backgroundColor = '#ff66cc'; // Cor padr√£o do input de cor
    chatterImageUpload.value = ''; // Limpa sele√ß√£o de arquivo

    // Muda para a aba "Participantes Convidados" para ver o rec√©m-criado
    document.querySelector('.modal-tab[data-tab="invited-tab"]').click();
}


// Atualiza o contador de espectadores na UI
function updateViewersCount() {
    if (viewersCountElement) {
        viewersCountElement.textContent = activeChatters.length + 4; // 4 espectadores base + ativos
    }
}

// --- Menu de Op√ß√µes ‚öôÔ∏è ---

// Inicializa listeners e carrega valores para o menu de op√ß√µes
function initOptionsMenu() {
    // Bot√£o para mostrar/ocultar menu
    optionsBtn.addEventListener('click', () => {
        const isHidden = optionsMenu.classList.toggle('hidden');
        optionsBtn.textContent = isHidden ? 'Op√ß√µes' : 'Fechar Op√ß√µes';
    });

    // Slider de M√°ximo de Tentativas
    maxRetriesSlider.addEventListener('input', (e) => {
        options.maxRetries = parseInt(e.target.value);
        maxRetriesValue.textContent = options.maxRetries;
        // üí° N√£o precisa salvar a cada input, pode salvar ao fechar o menu ou com bot√£o "Salvar Op√ß√µes"
        // saveOptions();
    });
    maxRetriesSlider.addEventListener('change', saveOptions); // Salva quando soltar o slider


    // Slider de For√ßa/Sarcasmo da Resposta
    responseStrengthSlider.addEventListener('input', (e) => {
        options.responseStrength = parseInt(e.target.value);
        responseStrengthValue.textContent = options.responseStrength;
        // saveOptions(); // Salvar a cada input pode ser excessivo
    });
    responseStrengthSlider.addEventListener('change', saveOptions);

    // Toggle de Tema Escuro/Claro
    themeToggle.addEventListener('change', (e) => {
        options.darkMode = e.target.checked;
        setTheme(options.darkMode);
        saveOptions();
    });

    // Aplica valores carregados aos controles
    maxRetriesSlider.value = options.maxRetries;
    maxRetriesValue.textContent = options.maxRetries;
    responseStrengthSlider.value = options.responseStrength;
    responseStrengthValue.textContent = options.responseStrength;
    themeToggle.checked = options.darkMode;
}

// Carrega op√ß√µes salvas do localStorage
function loadOptions() {
    const savedOptions = localStorage.getItem('blakeReactionOptions');
    if (savedOptions) {
        try {
            const parsed = JSON.parse(savedOptions);
            // Mescla com as op√ß√µes padr√£o para garantir que todas as chaves existam
            // As op√ß√µes salvas sobrescrevem as padr√£o se existirem
            options = { ...options, ...parsed };
        } catch (e) {
            console.error("Erro ao carregar op√ß√µes, usando padr√µes.", e);
        }
    }
}

// Salva o objeto 'options' atual no localStorage
function saveOptions() {
    localStorage.setItem('blakeReactionOptions', JSON.stringify(options));
}

// Aplica o tema (dark/light) ao body
function setTheme(darkMode) {
    document.body.classList.toggle('light-mode', !darkMode);
    // Atualiza a cor da mensagem de status para garantir contraste
    updateStatus(statusMessage.textContent);
}


// --- Inicializa√ß√£o da Aplica√ß√£o ---

// Fun√ß√£o principal de inicializa√ß√£o
function init() {
  loadOptions(); // ‚öôÔ∏è Carrega op√ß√µes primeiro
  loadSavedCharacter(); // ‚ú® Carrega dados do personagem (usa nome carregado)

  initOptionsMenu(); // ‚öôÔ∏è Inicializa listeners do menu de op√ß√µes
  initCustomChattersFeature(); // üë§ Inicializa modal e lista de participantes
  initMoodBoostButtons(); // üòä Inicializa bot√µes de boost de humor

  // Garante que pain√©is colaps√°veis comecem fechados
  if (customizerPanel) customizerPanel.classList.add('hidden');
  if (optionsMenu) optionsMenu.classList.add('hidden');
  if (streamingPanel) streamingPanel.classList.add('hidden');

  // Listeners para upload de imagens de humor
  moodImageSelectors.forEach(selector => {
      const input = selector.querySelector('.mood-image-input');
      if (input) input.addEventListener('change', handleMoodImageUpload);
  });

  // Atualiza elementos com nome do personagem
  updateCharacterNameSpans();
  updateViewersCount(); // Define contagem inicial de espectadores

  // Carrega personagens da cole√ß√£o online (ass√≠ncrono)
  loadStreamingCharacters().catch(error => console.error("Falha inicial ao carregar stream:", error));

  // Define imagem inicial de Blake
  blakeImage.src = blakeMoods.normal.image;

  // Define estado inicial dos toggles e humor
  autoReactToggle.checked = localStorage.getItem('autoReactionEnabled') === 'false' ? false : true; // Carrega prefer√™ncia
  autoReactionEnabled = autoReactToggle.checked;
  ttsToggle.checked = localStorage.getItem('ttsEnabled') === 'true'; // Carrega prefer√™ncia
  ttsEnabled = ttsToggle.checked;
  userSelectedMood = localStorage.getItem('userSelectedMood') || 'auto'; // Carrega prefer√™ncia
  moodSelect.value = userSelectedMood;

  // Atualiza visuais do humor
  updateMoodVisuals();

  // Define visibilidade do painel de debug
  const debugVisible = localStorage.getItem('debugVisible');
  if (debugPanel && debugToggle) {
      const showDebug = debugVisible !== 'false'; // Mostra por padr√£o se n√£o estiver salvo como false
      debugPanel.classList.toggle('hidden', !showDebug);
      debugToggle.textContent = showDebug ? 'Ocultar Debug' : 'Mostrar Debug';
      debugToggle.addEventListener('click', toggleDebugPanel);
  }

  // Prepara a s√≠ntese de voz (carrega vozes)
  if (window.speechSynthesis && window.speechSynthesis.onvoiceschanged !== undefined) {
    window.speechSynthesis.onvoiceschanged = () => {
        console.log("Vozes TTS carregadas.");
        // A sele√ß√£o da voz ocorre dentro da fun√ß√£o speakText
    };
  }

  // Define mensagem de status inicial
  updateStatus(`${currentCharacter.name} est√° relaxando... Envie um v√≠deo para ver a rea√ß√£o!`);
  // Define texto inicial do bal√£o de fala
  if (reactionText) reactionText.textContent = blakeMoods.normal.phrases[0];

  // Gera mensagens iniciais de chat da IA e inicia chat ocioso
  generateInitialChatMessages();

  // Define o tema inicial
  setTheme(options.darkMode);

  // O bot√£o de rea√ß√£o manual come√ßa oculto
  if (reactButton) reactButton.style.display = 'none';

  // Listener para mostrar/ocultar personalizador
  toggleCustomizer.addEventListener('click', () => {
      const isHidden = customizerPanel.classList.toggle('hidden');
      toggleCustomizer.textContent = isHidden ? 'Personalizar Personagem' : 'Ocultar Personalizador';
      // Fecha outros pain√©is se abrir este
      if (!isHidden) {
          optionsMenu.classList.add('hidden');
          optionsBtn.textContent = 'Op√ß√µes';
          streamingPanel.classList.add('hidden');
          currentlyStreamingBtn.textContent = 'Em Transmiss√£o';
      }
  });

   // Listener para mostrar/ocultar painel "Em Transmiss√£o"
  currentlyStreamingBtn.addEventListener('click', () => {
    const isHidden = streamingPanel.classList.toggle('hidden');
    currentlyStreamingBtn.textContent = isHidden ? 'Em Transmiss√£o' : 'Fechar Transmiss√£o';
    if (!isHidden) { // Se abriu, carrega/atualiza a lista
        loadStreamingCharacters().catch(error => console.error("Erro ao recarregar stream:", error));
        // Fecha outros pain√©is
        customizerPanel.classList.add('hidden');
        toggleCustomizer.textContent = 'Personalizar Personagem';
        optionsMenu.classList.add('hidden');
        optionsBtn.textContent = 'Op√ß√µes';
    }
  });

  // Listener para mostrar/ocultar painel de Op√ß√µes
   optionsBtn.addEventListener('click', () => {
      const isHidden = optionsMenu.classList.toggle('hidden');
      optionsBtn.textContent = isHidden ? 'Op√ß√µes' : 'Fechar Op√ß√µes';
      // Fecha outros pain√©is se abrir este
      if (!isHidden) {
          customizerPanel.classList.add('hidden');
          toggleCustomizer.textContent = 'Personalizar Personagem';
          streamingPanel.classList.add('hidden');
          currentlyStreamingBtn.textContent = 'Em Transmiss√£o';
      }
  });
}

// ü§ñ Fun√ß√£o separada para gerar as mensagens iniciais do chat
async function generateInitialChatMessages() {
    try {
        // Chatters padr√£o se nenhum customizado estiver ativo
        const initialChatters = activeChatters.length > 0 ? activeChatters : [
            { name: 'Zangos', personality: 'engra√ßado e um pouco ca√≥tico', color: '#ff5722' },
            { name: 'Connie', personality: 'anal√≠tica e curiosa', color: '#2196f3' },
            { name: 'Beary', personality: 'c√≠nico mas com um bom cora√ß√£o', color: '#8bc34a' }
            // { name: 'Starlight', personality: 'm√≠stica e sonhadora', color: '#9c27b0' } // Removido para menos spam inicial
        ];

        // Gera mensagem de sauda√ß√£o para cada um
        for (const chatter of initialChatters) {
            const avatar = chatter.image || `https://ui-avatars.com/api/?name=${encodeURIComponent(chatter.name)}&background=random&color=fff&size=24`;
            const systemPrompt = `Voc√™ √© um espectador chamado ${chatter.name} (${chatter.personality}) no chat da livestream de ${currentCharacter.name} que acabou de entrar. Gere uma √öNICA mensagem de sauda√ß√£o curta e casual (m√°x 10 palavras) que ${chatter.name} postaria ao entrar. Use emotes se apropriado. N√ÉO use hashtags. Responda em PORTUGU√äS BRASILEIRO.`;
            const userPrompt = `Gere a sauda√ß√£o de ${chatter.name}.`;

            try {
                const completion = await window.websim.ai.vision.chat.completions.create({
                     model: "gpt-4-turbo-preview", max_tokens: 20,
                     messages: [{ role: "system", content: systemPrompt }, { role: "user", content: userPrompt }]
                 });
                addChatMessage(chatter.name, completion.choices[0].message.content.trim(), chatter.color, avatar);
                await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 800)); // Delay entre mensagens
            } catch (innerError) {
                console.warn(`Falha ao gerar sauda√ß√£o para ${chatter.name}:`, innerError);
                // Fallback simples para sauda√ß√£o
                addChatMessage(chatter.name, `E a√≠, ${currentCharacter.name}! Cheguei!`, chatter.color, avatar);
                 await new Promise(resolve => setTimeout(resolve, 500));
            }
        }

        // Mensagem de boas-vindas do personagem principal (Blake)
        setTimeout(async () => {
            const welcomeSystemPrompt = `Voc√™ √© ${currentCharacter.name}, ${currentCharacter.personality}. Voc√™ est√° cumprimentando os espectadores no chat da sua livestream. Gere uma mensagem de boas-vindas casual e curta (1-2 frases). Use sua personalidade felina e LGBTQ+ se apropriado. N√ÉO use hashtags. Responda em PORTUGU√äS BRASILEIRO.`;
            const welcomeUserPrompt = `Gere a mensagem de boas-vindas de ${currentCharacter.name}.`;

            try {
                 const welcomeCompletion = await window.websim.ai.vision.chat.completions.create({
                     model: "gpt-4-turbo-preview", max_tokens: 40,
                     messages: [{ role: "system", content: welcomeSystemPrompt }, { role: "user", content: welcomeUserPrompt }]
                 });
                const welcomeMessage = welcomeCompletion.choices[0].message.content.trim();
                addChatMessage(currentCharacter.name, welcomeMessage, '#ff66cc', blakeMoods.happy.image); // Usa imagem feliz para boas-vindas
            } catch (error) {
                 console.warn("Falha ao gerar boas-vindas do Blake:", error);
                 addChatMessage(currentCharacter.name, `E a√≠, gatinhes! Prontos pra reagir? Mandem v√≠deo! *ronrona*`, '#ff66cc', blakeMoods.happy.image);
            } finally {
                startIdleChat(); // Inicia o chat ocioso AP√ìS as boas-vindas
            }
        }, 1500); // Delay ap√≥s as mensagens dos espectadores

    } catch (error) {
        console.error('Erro geral ao gerar mensagens iniciais de chat:', error);
        updateDebugInfo("‚ö†Ô∏è Erro ao gerar msgs iniciais.");
        // Fallback MUITO simples se a primeira chamada falhar
        addChatMessage(currentCharacter.name, `Oi, chat! T√¥ por aqui!`, '#ff66cc', blakeMoods.normal.image);
        startIdleChat();
    }
}


// üé≤ Fun√ß√£o para escolher um humor aleat√≥rio com pesos (mais chance de normal/feliz)
function getRandomMoodWeighted() {
    const moods = ['normal', 'normal', 'normal', 'happy', 'happy', 'sad', 'angry', 'shocked', 'praying'];
    // Adiciona traumatized com menos frequ√™ncia
    if (Math.random() < 0.15) moods.push('traumatized');
    if (Math.random() < 0.2) moods.push('angry'); // Mais chance de raiva
    if (Math.random() < 0.25) moods.push('sad'); // Mais chance de triste
    if (Math.random() < 0.4) moods.push('happy'); // Mais chance de feliz

    // Pondera baseado no humor atual (tende a n√£o mudar drasticamente, exceto para shocked/traumatized)
    const moodInfluence = currentMoodValue / 100; // 0 a 1
    const randomFactor = Math.random();

    if (randomFactor < moodInfluence * 0.6 && currentMoodValue > 60) return 'happy'; // Tende a feliz se j√° est√° alto
    if (randomFactor > (1 - moodInfluence * 0.6) && currentMoodValue < 40) return 'sad'; // Tende a triste se j√° est√° baixo

    return moods[Math.floor(Math.random() * moods.length)];
}

// üöÄ Chama a fun√ß√£o init para iniciar a aplica√ß√£o quando o DOM estiver pronto
document.addEventListener('DOMContentLoaded', init);

  </script>
</body>
</html>
